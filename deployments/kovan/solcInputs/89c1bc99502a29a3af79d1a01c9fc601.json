{
  "language": "Solidity",
  "sources": {
    "contracts/adapters/AmmAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IAmmAdapter} from \"./IAmmAdapter.sol\";\n\n/**\n * @notice ProtocolAdapter is used to shadow IProtocolAdapter\n * to provide functions that delegatecall's the underlying IProtocolAdapter functions.\n */\nlibrary AmmAdapter {\n    function delegateBuyLp(\n        IAmmAdapter adapter,\n        uint256 amt,\n        uint256 tradeAmt,\n        uint256 minWbtcAmtOut,\n        uint256 minDiggAmtOut\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"buyLp(uint256,uint256,uint256,uint256)\",\n                    amt,\n                    tradeAmt,\n                    minWbtcAmtOut,\n                    minDiggAmtOut\n                )\n            );\n        revertWhenFail(success, result);\n    }\n\n    function revertWhenFail(bool success, bytes memory returnData)\n        private\n        pure\n    {\n        if (success) return;\n        revert(getRevertMsg(returnData));\n    }\n\n    function getRevertMsg(bytes memory _returnData)\n        private\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"ProtocolAdapter: reverted\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/adapters/IAmmAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\ninterface IAmmAdapter {\n    function protocolName() external pure returns (string memory);\n\n    function nonFungible() external pure returns (bool);\n\n    function expectedWbtcOut(uint256 ethAmt) external view returns (uint256);\n\n    function expectedDiggOut(uint256 wbtcAmt)\n        external\n        view\n        returns (uint256 diggOut, uint256 tradeAmt);\n\n    function buyLp(\n        uint256 amt,\n        uint256 tradeAmt,\n        uint256 minWbtcAmtOut,\n        uint256 minDiggAmtOut\n    ) external payable;\n}\n"
    },
    "contracts/experimental/StakedPut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\nimport {\n    AggregatorV3Interface\n} from \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n\nimport {IHegicOptions} from \"../interfaces/HegicInterface.sol\";\nimport {\n    ProtocolAdapterTypes,\n    IProtocolAdapter\n} from \"../adapters/IProtocolAdapter.sol\";\nimport {IAmmAdapter} from \"../adapters/IAmmAdapter.sol\";\nimport {AmmAdapter} from \"../adapters/AmmAdapter.sol\";\n\nimport {ProtocolAdapter} from \"../adapters/ProtocolAdapter.sol\";\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\nimport {UniswapAdapter} from \"../adapters/UniswapAdapter.sol\";\n\nimport {StakedPutStorageV1} from \"../storage/StakedPutStorage.sol\";\n\ncontract StakedPut is DSMath, StakedPutStorageV1 {\n    event PositionCreated(\n        address indexed account,\n        uint256 indexed positionID,\n        uint256 amount\n    );\n    event Exercised(\n        address indexed account,\n        uint256 indexed positionID,\n        uint256 totalProfit\n    );\n\n    struct BuyInstrumentParams {\n        uint256 putStrikePrice;\n        uint256 optionAmount;\n        uint256 putMaxCost;\n        uint256 expiry;\n        uint256 lpAmt;\n        uint256 tradeAmt;\n        uint256 minWbtcAmtOut;\n        uint256 minDiggAmtOut;\n    }\n\n    using AmmAdapter for IAmmAdapter;\n    using ProtocolAdapter for IProtocolAdapter;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IRibbonFactory public immutable factory;\n    IProtocolAdapter public immutable adapter;\n    IAmmAdapter public immutable iUniswapAdapter;\n    AggregatorV3Interface public immutable priceProvider;\n\n    address payable public uniswapAdapterAddress;\n    string private constant instrumentName = \"wbtc/digg-staked-put\";\n    uint256 private constant timePeriod = 2419199;\n    string private constant venue = \"HEGIC\";\n    uint8 private constant venueID = 0;\n\n    ProtocolAdapterTypes.OptionType public constant optionType =\n        ProtocolAdapterTypes.OptionType.Put;\n    address public constant ethAddress = address(0);\n    address public immutable wbtcAddress;\n    address public immutable underlying;\n    address public immutable strikeAsset;\n    address public immutable collateralAsset;\n    address public immutable optionsAddress;\n    address public immutable adapterAddress;\n\n    constructor(\n        address _factory,\n        address payable _uniswapAdapterAddress,\n        address _wbtcAddress,\n        address _wbtcOptionsAddress,\n        address _collateralAsset,\n        address _priceFeed\n    ) {\n        require(_factory != address(0), \"!_factory\");\n        require(_uniswapAdapterAddress != address(0), \"!_uniswapAdapter\");\n        require(_wbtcAddress != address(0), \"!_wbtc\");\n        require(_wbtcOptionsAddress != address(0), \"!_wbtcOptions\");\n        require(_collateralAsset != address(0), \"!_collateral\");\n        require(_priceFeed != address(0), \"!_priceFeed\");\n\n        wbtcAddress = _wbtcAddress;\n        underlying = _wbtcAddress;\n        strikeAsset = _wbtcAddress;\n        collateralAsset = _collateralAsset;\n        priceProvider = AggregatorV3Interface(_priceFeed);\n        IRibbonFactory factoryInstance = IRibbonFactory(_factory);\n        iUniswapAdapter = IAmmAdapter(_uniswapAdapterAddress);\n        uniswapAdapterAddress = _uniswapAdapterAddress;\n        address _adapterAddress = factoryInstance.getAdapter(venue);\n        require(_adapterAddress != address(0), \"Adapter not set\");\n        adapterAddress = _adapterAddress;\n        factory = factoryInstance;\n        adapter = IProtocolAdapter(_adapterAddress);\n        optionsAddress = _wbtcOptionsAddress;\n    }\n\n    function initialize() external initializer {}\n\n    receive() external payable {}\n\n    function getName() public pure returns (string memory) {\n        return instrumentName;\n    }\n\n    function getCurrentPrice() public view returns (uint256) {\n        (, int256 latestPrice, , , ) = priceProvider.latestRoundData();\n        uint256 currentPrice = uint256(latestPrice);\n        return currentPrice.mul(10**10);\n    }\n\n    //input currency is eth\n    function getInputs(uint256 amt)\n        public\n        view\n        returns (\n            uint256 wbtcSize,\n            uint256 expDigg,\n            uint256 tradeAmt,\n            uint256 premium,\n            uint256 totalCost,\n            uint256 currentPrice,\n            uint256 expiry\n        )\n    {\n        wbtcSize = iUniswapAdapter.expectedWbtcOut(amt);\n\n        (expDigg, tradeAmt) = iUniswapAdapter.expectedDiggOut(wbtcSize);\n\n        //set expiry to a month from now\n        //set strike to atm\n        expiry = block.timestamp + timePeriod;\n        currentPrice = uint256(getCurrentPrice());\n\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                expiry,\n                currentPrice,\n                optionType,\n                ethAddress\n            );\n\n        premium = adapter.premium(optionTerms, wbtcSize);\n        totalCost = amt.add(premium);\n    }\n\n    function buyInstrument(BuyInstrumentParams calldata params) public payable {\n        require(msg.value > 0, \"input must be eth\");\n        iUniswapAdapter.delegateBuyLp(\n            params.lpAmt,\n            params.tradeAmt,\n            params.minWbtcAmtOut,\n            params.minDiggAmtOut\n        );\n        uint256 positionID = buyPutFromAdapter(params);\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) payable(msg.sender).transfer(balance);\n\n        emit PositionCreated(msg.sender, positionID, params.lpAmt);\n    }\n\n    function exercisePosition(uint256 positionID)\n        external\n        nonReentrant\n        returns (uint256 totalProfit)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[msg.sender][positionID];\n        require(!position.exercised, \"Already exercised\");\n\n        uint32 optionID;\n\n        optionID = position.putOptionID;\n\n        uint256 amount = position.amount;\n\n        uint256 profit =\n            adapter.delegateExerciseProfit(optionsAddress, optionID, amount);\n        if (profit > 0) {\n            adapter.delegateExercise(\n                optionsAddress,\n                optionID,\n                amount,\n                msg.sender\n            );\n        }\n\n        totalProfit += profit;\n\n        position.exercised = true;\n\n        emit Exercised(msg.sender, positionID, totalProfit);\n    }\n\n    function exerciseProfit(address account, uint256 positionID)\n        external\n        view\n        returns (uint256)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return 0;\n\n        uint256 profit = 0;\n\n        uint256 amount = position.amount;\n\n        uint32 optionID;\n\n        optionID = position.putOptionID;\n\n        profit += adapter.delegateExerciseProfit(\n            optionsAddress,\n            optionID,\n            amount\n        );\n        return profit;\n    }\n\n    function canExercise(address account, uint256 positionID)\n        external\n        view\n        returns (bool)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return false;\n\n        bool canExercisePut = false;\n\n        uint32 optionID;\n\n        optionID = position.putOptionID;\n\n        bool canExerciseOptions =\n            adapter.canExercise(optionsAddress, optionID, position.amount);\n\n        if (canExerciseOptions) {\n            canExercisePut = true;\n        }\n        return canExercisePut;\n    }\n\n    //make this internal for production\n    function buyPutFromAdapter(BuyInstrumentParams calldata params)\n        public\n        payable\n        nonReentrant\n        returns (uint256 positionID)\n    {\n        require(\n            block.timestamp < params.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                params.expiry,\n                params.putStrikePrice,\n                optionType,\n                ethAddress\n            );\n\n        uint256 optionID256 =\n            adapter.delegatePurchase(\n                optionTerms,\n                params.optionAmount,\n                params.putMaxCost\n            );\n        uint32 optionID = uint32(optionID256);\n\n        InstrumentPosition memory position =\n            InstrumentPosition(false, venueID, optionID, params.optionAmount);\n\n        positionID = instrumentPositions[msg.sender].length;\n        instrumentPositions[msg.sender].push(position);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/DSMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/interfaces/HegicInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nenum HegicOptionType {Invalid, Put, Call}\nenum State {Inactive, Active, Exercised, Expired}\n\nstruct HegicOption {\n    State state;\n    address payable holder;\n    uint256 strike;\n    uint256 amount;\n    uint256 lockedAmount;\n    uint256 premium;\n    uint256 expiration;\n    HegicOptionType optionType;\n}\n\ninterface IHegicOptions {\n    event Create(\n        uint256 indexed id,\n        address indexed account,\n        uint256 settlementFee,\n        uint256 totalFee\n    );\n\n    event Exercise(uint256 indexed id, uint256 profit);\n    event Expire(uint256 indexed id, uint256 premium);\n\n    function options(uint256)\n        external\n        view\n        returns (\n            State state,\n            address payable holder,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            uint256 premium,\n            uint256 expiration,\n            HegicOptionType optionType\n        );\n\n    function create(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    ) external payable returns (uint256 optionID);\n\n    function exercise(uint256 optionID) external;\n\n    function priceProvider() external view returns (address);\n}\n\ninterface IHegicETHOptions is IHegicOptions {\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n}\n\ninterface IHegicBTCOptions is IHegicOptions {\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 totalETH,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n}\n\ninterface IHegicRewards {\n    function hegic() external view returns (IERC20);\n\n    function hegicOptions() external view returns (IHegicOptions);\n\n    function rewardsRate() external view returns (uint256);\n\n    function rewardedOptions(uint256 optionId) external view returns (bool);\n\n    function getReward(uint256 optionId) external;\n}\n"
    },
    "contracts/adapters/IProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nlibrary ProtocolAdapterTypes {\n    enum OptionType {Invalid, Put, Call}\n\n    // We have 2 types of purchase methods so far - by contract and by 0x.\n    // Contract is simple because it involves just specifying the option terms you want to buy.\n    // ZeroEx involves an off-chain API call which prepares a ZeroExOrder object to be passed into the tx.\n    enum PurchaseMethod {Invalid, Contract, ZeroEx}\n\n    /**\n     * @notice Terms of an options contract\n     * @param underlying is the underlying asset of the options. E.g. For ETH $800 CALL, ETH is the underlying.\n     * @param strikeAsset is the asset used to denote the asset paid out when exercising the option.\n     *        E.g. For ETH $800 CALL, USDC is the strikeAsset.\n     * @param collateralAsset is the asset used to collateralize a short position for the option.\n     * @param expiry is the expiry of the option contract. Users can only exercise after expiry in Europeans.\n     * @param strikePrice is the strike price of an optio contract.\n     *        E.g. For ETH $800 CALL, 800*10**18 is the USDC.\n     * @param optionType is the type of option, can only be OptionType.Call or OptionType.Put\n     * @param paymentToken is the token used to purchase the option.\n     *        E.g. Buy UNI/USDC CALL with WETH as the paymentToken.\n     */\n    struct OptionTerms {\n        address underlying;\n        address strikeAsset;\n        address collateralAsset;\n        uint256 expiry;\n        uint256 strikePrice;\n        ProtocolAdapterTypes.OptionType optionType;\n        address paymentToken;\n    }\n\n    /**\n     * @notice 0x order for purchasing otokens\n     * @param exchangeAddress [deprecated] is the address we call to conduct a 0x trade.\n     * Slither flagged this as a potential vulnerability so we hardcoded it.\n     * @param buyTokenAddress is the otoken address\n     * @param sellTokenAddress is the token used to purchase USDC. This is USDC most of the time.\n     * @param allowanceTarget is the address the adapter needs to provide sellToken allowance to so the swap happens\n     * @param protocolFee is the fee paid (in ETH) when conducting the trade\n     * @param makerAssetAmount is the buyToken amount\n     * @param takerAssetAmount is the sellToken amount\n     * @param swapData is the encoded msg.data passed by the 0x api response\n     */\n    struct ZeroExOrder {\n        address exchangeAddress;\n        address buyTokenAddress;\n        address sellTokenAddress;\n        address allowanceTarget;\n        uint256 protocolFee;\n        uint256 makerAssetAmount;\n        uint256 takerAssetAmount;\n        bytes swapData;\n    }\n}\n\ninterface IProtocolAdapter {\n    /**\n     * @notice Emitted when a new option contract is purchased\n     */\n    event Purchased(\n        address indexed caller,\n        string indexed protocolName,\n        address indexed underlying,\n        uint256 amount,\n        uint256 optionID\n    );\n\n    /**\n     * @notice Emitted when an option contract is exercised\n     */\n    event Exercised(\n        address indexed caller,\n        address indexed options,\n        uint256 indexed optionID,\n        uint256 amount,\n        uint256 exerciseProfit\n    );\n\n    /**\n     * @notice Name of the adapter. E.g. \"HEGIC\", \"OPYN_V1\". Used as index key for adapter addresses\n     */\n    function protocolName() external pure returns (string memory);\n\n    /**\n     * @notice Boolean flag to indicate whether to use option IDs or not.\n     * Fungible protocols normally use tokens to represent option contracts.\n     */\n    function nonFungible() external pure returns (bool);\n\n    /**\n     * @notice Returns the purchase method used to purchase options\n     */\n    function purchaseMethod()\n        external\n        pure\n        returns (ProtocolAdapterTypes.PurchaseMethod);\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(ProtocolAdapterTypes.OptionTerms calldata optionTerms)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (address);\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the number of options purchased\n     */\n    function premium(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view returns (uint256 cost);\n\n    /**\n     * @notice Amount of profit made from exercising an option contract (current price - strike price).\n     *         0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise.\n     */\n    function exerciseProfit(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256 profit);\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (bool);\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     */\n    function purchase(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable returns (uint256 optionID);\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise.\n     * @param recipient is the account that receives the exercised profits.\n     * This is needed since the adapter holds all the positions\n     */\n    function exercise(\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external payable;\n\n    /**\n     * @notice Opens a short position for a given `optionTerms`.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the short position amount\n     */\n    function createShort(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount\n    ) external returns (uint256);\n\n    /**\n     * @notice Closes an existing short position. In the future,\n     * we may want to open this up to specifying a particular short position to close.\n     */\n    function closeShort() external returns (uint256);\n}\n"
    },
    "contracts/adapters/ProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IProtocolAdapter, ProtocolAdapterTypes} from \"./IProtocolAdapter.sol\";\n\n/**\n * @notice ProtocolAdapter is used to shadow IProtocolAdapter to provide functions\n * that delegatecall's the underlying IProtocolAdapter functions.\n */\nlibrary ProtocolAdapter {\n    function delegateOptionsExist(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (bool) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"optionsExist((address,address,address,uint256,uint256,uint8,address))\",\n                    optionTerms\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (bool));\n    }\n\n    function delegateGetOptionsAddress(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (address) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"getOptionsAddress((address,address,address,uint256,uint256,uint8,address))\",\n                    optionTerms\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (address));\n    }\n\n    function delegatePremium(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"premium((address,address,address,uint256,uint256,uint8,address),uint256)\",\n                    optionTerms,\n                    purchaseAmount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateExerciseProfit(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"exerciseProfit(address,uint256,uint256)\",\n                    options,\n                    optionID,\n                    amount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchase(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount,\n        uint256 maxCost\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"purchase((address,address,address,uint256,uint256,uint8,address),uint256,uint256)\",\n                    optionTerms,\n                    purchaseAmount,\n                    maxCost\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchaseWithZeroEx(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        ProtocolAdapterTypes.ZeroExOrder calldata zeroExOrder\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    // solhint-disable-next-line\n                    \"purchaseWithZeroEx((address,address,address,uint256,uint256,uint8,address),(address,address,address,address,uint256,uint256,uint256,bytes))\",\n                    optionTerms,\n                    zeroExOrder\n                )\n            );\n        revertWhenFail(success, result);\n    }\n\n    function delegateExercise(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"exercise(address,uint256,uint256,address)\",\n                    options,\n                    optionID,\n                    amount,\n                    recipient\n                )\n            );\n        revertWhenFail(success, result);\n    }\n\n    function delegateClaimRewards(\n        IProtocolAdapter adapter,\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"claimRewards(address,uint256[])\",\n                    rewardsAddress,\n                    optionIDs\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateRewardsClaimable(\n        IProtocolAdapter adapter,\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"rewardsClaimable(address,uint256[])\",\n                    rewardsAddress,\n                    optionIDs\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateCreateShort(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms memory optionTerms,\n        uint256 amount\n    ) internal returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"createShort((address,address,address,uint256,uint256,uint8,address),uint256)\",\n                    optionTerms,\n                    amount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateCloseShort(IProtocolAdapter adapter)\n        internal\n        returns (uint256)\n    {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\"closeShort()\")\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function revertWhenFail(bool success, bytes memory returnData)\n        private\n        pure\n    {\n        if (success) return;\n        revert(getRevertMsg(returnData));\n    }\n\n    function getRevertMsg(bytes memory _returnData)\n        private\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"ProtocolAdapter: reverted\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/interfaces/IRibbonFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IRibbonFactory {\n    function isInstrument(address instrument) external returns (bool);\n\n    function getAdapter(string calldata protocolName)\n        external\n        view\n        returns (address);\n\n    function getAdapters()\n        external\n        view\n        returns (address[] memory adaptersArray);\n\n    function burnGasTokens() external;\n}\n"
    },
    "contracts/adapters/UniswapAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {IUniswapV2Pair} from \"../interfaces/IUniswapV2Pair.sol\";\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router.sol\";\n\ncontract UniswapAdapter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public constant ethAddress = address(0);\n    address public immutable wethAddress;\n    address public immutable wbtcAddress;\n    address public immutable diggAddress;\n    string private constant _name = \"UNISWAP\";\n    bool private constant _nonFungible = true;\n    IUniswapV2Router02 public immutable sushiswapRouter;\n    IUniswapV2Pair public immutable wbtcDiggSushiswap;\n    IERC20 public immutable wbtcToken;\n    IERC20 public immutable diggToken;\n    uint256 private constant deadlineBuffer = 150;\n\n    constructor(\n        address _sushiswapRouter,\n        address _wbtcAddress,\n        address _wethAddress,\n        address _wbtcDiggSushiswap,\n        address _diggAddress\n    ) {\n        require(_sushiswapRouter != address(0), \"!_sushiswapRouter\");\n        require(_wethAddress != address(0), \"!_weth\");\n        require(_wbtcAddress != address(0), \"!_wbtc\");\n        require(_wbtcDiggSushiswap != address(0), \"!_wbtcDiggSushiswap\");\n        require(_diggAddress != address(0), \"!_diggAddress\");\n\n        wbtcAddress = _wbtcAddress;\n        wethAddress = _wethAddress;\n        diggAddress = _diggAddress;\n        sushiswapRouter = IUniswapV2Router02(_sushiswapRouter);\n        wbtcDiggSushiswap = IUniswapV2Pair(_wbtcDiggSushiswap);\n        wbtcToken = IERC20(_wbtcAddress);\n        diggToken = IERC20(_diggAddress);\n    }\n\n    receive() external payable {}\n\n    function protocolName() public pure returns (string memory) {\n        return _name;\n    }\n\n    function nonFungible() external pure returns (bool) {\n        return _nonFungible;\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // Code from Alpha Homora\n    // The core math involved in getting optimal swap amt to provide amm liquidity\n    function getSwapAmt(uint256 amtA, uint256 resA)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            sqrt(amtA.mul(resA.mul(3988000) + amtA.mul(3988009))).sub(\n                amtA.mul(1997)\n            ) / 1994;\n    }\n\n    function expectedWbtcOut(uint256 ethAmt) public view returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = wethAddress;\n        path[1] = wbtcAddress;\n        uint256 wbtcOut = sushiswapRouter.getAmountsOut(ethAmt, path)[1];\n        return wbtcOut;\n    }\n\n    //this function returns both the expected digg amount out as well as the input trade amt of wbtc used\n    //these are both needed as inputs to buyLp\n    function expectedDiggOut(uint256 wbtcAmt)\n        public\n        view\n        returns (uint256 diggOut, uint256 tradeAmt)\n    {\n        (uint112 reserveAmt, , ) =\n            IUniswapV2Pair(wbtcDiggSushiswap).getReserves();\n        tradeAmt = getSwapAmt(reserveAmt, wbtcAmt);\n        address[] memory path = new address[](2);\n        path[0] = wbtcAddress;\n        path[1] = diggAddress;\n        diggOut = sushiswapRouter.getAmountsOut(tradeAmt, path)[1];\n    }\n\n    function convertEthToToken(\n        uint256 inputAmount,\n        address addr,\n        uint256 amountOutMin\n    ) internal returns (uint256) {\n        uint256 amtOut =\n            _convertEthToToken(\n                inputAmount,\n                addr,\n                amountOutMin,\n                sushiswapRouter\n            );\n        return amtOut;\n    }\n\n    function convertTokenToToken(\n        address addr1,\n        address addr2,\n        uint256 amount,\n        uint256 amountOutMin\n    ) internal returns (uint256) {\n        uint256 amtOut =\n            _convertTokenToToken(\n                addr1,\n                addr2,\n                amount,\n                amountOutMin,\n                sushiswapRouter\n            );\n        return amtOut;\n    }\n\n    function addLiquidity(\n        address token1,\n        address token2,\n        uint256 amount1,\n        uint256 amount2\n    ) internal returns (uint256) {\n        uint256 lpAmt =\n            _addLiquidity(token1, token2, amount1, amount2, sushiswapRouter);\n        return lpAmt;\n    }\n\n    function _convertEthToToken(\n        uint256 inputAmount,\n        address addr,\n        uint256 amountOutMin,\n        IUniswapV2Router02 router\n    ) internal returns (uint256) {\n        uint256 deadline = block.timestamp + deadlineBuffer;\n        address[] memory path = new address[](2);\n        path[0] = wethAddress;\n        path[1] = addr;\n        uint256 amtOut =\n            router.swapExactETHForTokens{value: inputAmount}(\n                amountOutMin,\n                path,\n                address(this),\n                deadline\n            )[1];\n        return amtOut;\n    }\n\n    function _convertTokenToToken(\n        address addr1,\n        address addr2,\n        uint256 amount,\n        uint256 amountOutMin,\n        IUniswapV2Router02 router\n    ) internal returns (uint256) {\n        uint256 deadline = block.timestamp + deadlineBuffer;\n        address[] memory path = new address[](2);\n        path[0] = addr1;\n        path[1] = addr2;\n        if (wbtcToken.allowance(address(this), address(router)) == 0) {\n            wbtcToken.safeApprove(address(router), type(uint256).max);\n        }\n        uint256 amtOut =\n            router.swapExactTokensForTokens(\n                amount,\n                amountOutMin,\n                path,\n                address(this),\n                deadline\n            )[1];\n        return amtOut;\n    }\n\n    function _addLiquidity(\n        address token1,\n        address token2,\n        uint256 amount1,\n        uint256 amount2,\n        IUniswapV2Router02 router\n    ) internal returns (uint256) {\n        uint256 deadline = block.timestamp + deadlineBuffer;\n        if (wbtcToken.allowance(address(this), address(router)) < amount1) {\n            wbtcToken.safeApprove(address(router), type(uint256).max);\n        }\n        if (diggToken.allowance(address(this), address(router)) < amount2) {\n            diggToken.safeApprove(address(router), type(uint256).max);\n        }\n        (, , uint256 lpAmt) =\n            router.addLiquidity(\n                token1,\n                token2,\n                amount1,\n                amount2,\n                0,\n                0,\n                address(this),\n                deadline\n            );\n        return lpAmt;\n    }\n\n    //By the time this function is called the user bal should be in wbtc\n    //calculates optimal swap amt for minimal leftover funds and buys Digg\n    // Provides liquidity and transfers lp token to msg.sender\n    function _buyLp(\n        uint256 userWbtcBal,\n        address traderAccount,\n        uint256 tradeAmt,\n        uint256 minDiggAmtOut\n    ) internal {\n        uint256 diggAmt =\n            convertTokenToToken(\n                wbtcAddress,\n                diggAddress,\n                tradeAmt,\n                minDiggAmtOut\n            );\n        uint256 lpAmt =\n            addLiquidity(wbtcAddress, diggAddress, userWbtcBal, diggAmt);\n        require(\n            wbtcDiggSushiswap.transfer(traderAccount, lpAmt),\n            \"transfer failed\"\n        );\n    }\n\n    // token input should be either wbtc or eth\n    // valid exchange venues are sushiswap and uniswap\n    // the minWbtcAmtOut param isnt used when users pass in wbtc directly\n    // use the  expectedWbtcAmtOut and expectedDiggAmtOut functions\n    // off chain to calculate trade_amt, minWbtcAmtOut and minDiggAmtOut\n    function buyLp(\n        uint256 amt,\n        uint256 tradeAmt,\n        uint256 minWbtcAmtOut,\n        uint256 minDiggAmtOut\n    ) public payable {\n        require(msg.value >= amt, \"not enough funds\");\n        uint256 wbtcAmt = convertEthToToken(amt, wbtcAddress, minWbtcAmtOut);\n        _buyLp(wbtcAmt, msg.sender, tradeAmt, minDiggAmtOut);\n    }\n}\n"
    },
    "contracts/storage/StakedPutStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\n\ncontract StakedPutStorageV1 is\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    ReentrancyGuard\n{\n    struct InstrumentPosition {\n        bool exercised;\n        uint8 putVenueID;\n        uint32 putOptionID;\n        uint256 amount;\n    }\n\n    mapping(address => InstrumentPosition[]) instrumentPositions;\n\n    function numOfPositions(address _account) public view returns (uint256) {\n        return instrumentPositions[_account].length;\n    }\n\n    function getInstrumentPositions(address account)\n        external\n        view\n        returns (InstrumentPosition[] memory positions)\n    {\n        return instrumentPositions[account];\n    }\n\n    function instrumentPosition(address account, uint256 positionID)\n        external\n        view\n        returns (InstrumentPosition memory position)\n    {\n        return instrumentPositions[account][positionID];\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/instruments/RibbonThetaVaultYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\nimport {SafeERC20} from \"../lib/CustomSafeERC20.sol\";\n\nimport {\n    ProtocolAdapterTypes,\n    IProtocolAdapter\n} from \"../adapters/IProtocolAdapter.sol\";\nimport {ProtocolAdapter} from \"../adapters/ProtocolAdapter.sol\";\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IYearnRegistry, IYearnVault} from \"../interfaces/IYearn.sol\";\nimport {ISwap, Types} from \"../interfaces/ISwap.sol\";\nimport {OtokenInterface} from \"../interfaces/GammaInterface.sol\";\nimport {OptionsVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {IRibbonV2Vault} from \"../interfaces/IRibbonVaults.sol\";\n\ncontract RibbonThetaVaultYearn is DSMath, OptionsVaultStorage {\n    using ProtocolAdapter for IProtocolAdapter;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    string private constant _adapterName = \"OPYN_GAMMA\";\n\n    IProtocolAdapter public immutable adapter;\n    address public immutable asset;\n    address public immutable underlying;\n    address public immutable WETH;\n    address public immutable USDC;\n    bool public immutable isPut;\n    uint8 private immutable _decimals;\n\n    // Yearn vault contract\n    IYearnVault public immutable collateralToken;\n\n    // AirSwap Swap contract\n    // https://github.com/airswap/airswap-protocols/blob/master/source/swap/contracts/interfaces/ISwap.sol\n    ISwap public immutable SWAP_CONTRACT;\n\n    // 90% locked in options protocol, 10% of the pool reserved for withdrawals\n    uint256 public constant lockedRatio = 0.9 ether;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public immutable MINIMUM_SUPPLY;\n\n    uint256 public constant YEARN_WITHDRAWAL_BUFFER = 5; // 0.05%\n    uint256 public constant YEARN_WITHDRAWAL_SLIPPAGE = 5; // 0.05%\n\n    event ManagerChanged(address oldManager, address newManager);\n\n    event Deposit(address indexed account, uint256 amount, uint256 share);\n\n    event Withdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 share,\n        uint256 fee\n    );\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event WithdrawalFeeSet(uint256 oldFee, uint256 newFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event VaultSunset(address replacement);\n\n    event Migrate(\n        address account,\n        address replacement,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _asset is the asset used for collateral and premiums\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _collateralToken is the Yearn vault token used as the collateral\n     * @param _swapContract is the Airswap Swap contract\n     * @param _tokenDecimals is the decimals for the vault shares. Must match the decimals for _asset.\n     * @param _minimumSupply is the minimum supply for the asset balance and the share supply.\n     * @param _isPut is whether this is a put strategy.\n     * It's important to bake the _factory variable into the contract with the constructor\n     * If we do it in the `initialize` function, users get to set the factory variable and\n     * subsequently the adapter, which allows them to make a delegatecall, then selfdestruct the contract.\n     */\n    constructor(\n        address _asset,\n        address _factory,\n        address _weth,\n        address _usdc,\n        address _collateralToken,\n        address _swapContract,\n        uint8 _tokenDecimals,\n        uint256 _minimumSupply,\n        bool _isPut\n    ) {\n        require(_asset != address(0), \"!_asset\");\n        require(_factory != address(0), \"!_factory\");\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_collateralToken != address(0), \"!_collateralToken\");\n        require(_swapContract != address(0), \"!_swapContract\");\n        require(_tokenDecimals > 0, \"!_tokenDecimals\");\n        require(_minimumSupply > 0, \"!_minimumSupply\");\n\n        IRibbonFactory factoryInstance = IRibbonFactory(_factory);\n\n        address adapterAddr = factoryInstance.getAdapter(_adapterName);\n        require(adapterAddr != address(0), \"Adapter not set\");\n\n        asset = _isPut ? _usdc : _asset;\n        underlying = _asset;\n\n        collateralToken = IYearnVault(_collateralToken);\n        adapter = IProtocolAdapter(adapterAddr);\n        WETH = _weth;\n        USDC = _usdc;\n        SWAP_CONTRACT = ISwap(_swapContract);\n        _decimals = _tokenDecimals;\n        MINIMUM_SUPPLY = _minimumSupply;\n        isPut = _isPut;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _owner is the owner of the contract who can set the manager\n     * @param _feeRecipient is the recipient address for withdrawal fees.\n     * @param _initCap is the initial vault's cap on deposits, the manager can increase this as necessary.\n     * @param _tokenName is the name of the vault share token\n     * @param _tokenSymbol is the symbol of the vault share token\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _initCap,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external initializer {\n        require(_owner != address(0), \"!_owner\");\n        require(_feeRecipient != address(0), \"!_feeRecipient\");\n        require(_initCap > 0, \"_initCap > 0\");\n        require(bytes(_tokenName).length > 0, \"_tokenName != 0x\");\n        require(bytes(_tokenSymbol).length > 0, \"_tokenSymbol != 0x\");\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n        cap = _initCap;\n\n        // hardcode the initial withdrawal fee\n        instantWithdrawalFee = 0.005 ether;\n        feeRecipient = _feeRecipient;\n    }\n\n    /**\n     * @notice Sets the new manager of the vault.\n     * @param newManager is the new manager of the vault\n     */\n    function setManager(address newManager) external onlyOwner {\n        require(newManager != address(0), \"!newManager\");\n        address oldManager = manager;\n        manager = newManager;\n\n        emit ManagerChanged(oldManager, newManager);\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the new withdrawal fee\n     * @param newWithdrawalFee is the fee paid in tokens when withdrawing\n     */\n    function setWithdrawalFee(uint256 newWithdrawalFee) external onlyManager {\n        require(newWithdrawalFee > 0, \"withdrawalFee != 0\");\n\n        // cap max withdrawal fees to 30% of the withdrawal amount\n        require(newWithdrawalFee < 0.3 ether, \"withdrawalFee >= 30%\");\n\n        uint256 oldFee = instantWithdrawalFee;\n        emit WithdrawalFeeSet(oldFee, newWithdrawalFee);\n\n        instantWithdrawalFee = newWithdrawalFee;\n    }\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the underlying is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(asset == WETH, \"asset is not WETH\");\n        require(msg.value > 0, \"No value passed\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }\n\n    /**\n     * @notice Deposits the `asset` into the contract and mint vault shares.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        _deposit(amount);\n    }\n\n    /**\n     * @notice Deposits the `collateralToken` into the contract and mint vault shares.\n     * @param amount is the amount of `collateralToken` to deposit\n     */\n    function depositYieldToken(uint256 amount) external nonReentrant {\n        IERC20(address(collateralToken)).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 collateralToAssetBalance =\n            wmul(amount, collateralToken.pricePerShare().mul(_decimalShift()));\n\n        _deposit(collateralToAssetBalance);\n    }\n\n    /**\n     * @notice Mints the vault shares to the msg.sender\n     * @param amount is the amount of `asset` deposited\n     */\n    function _deposit(uint256 amount) private {\n        uint256 totalWithDepositedAmount = totalBalance();\n        require(totalWithDepositedAmount < cap, \"Cap exceeded\");\n        require(\n            totalWithDepositedAmount >= MINIMUM_SUPPLY,\n            \"Insufficient asset balance\"\n        );\n\n        // amount needs to be subtracted from totalBalance because it has already been\n        // added to it from either IWETH.deposit and IERC20.safeTransferFrom\n        uint256 total = totalWithDepositedAmount.sub(amount);\n\n        uint256 shareSupply = totalSupply();\n\n        // Following the pool share calculation from Alpha Homora:\n        // solhint-disable-next-line\n        // https://github.com/AlphaFinanceLab/alphahomora/blob/340653c8ac1e9b4f23d5b81e61307bf7d02a26e8/contracts/5/Bank.sol#L104\n        uint256 share =\n            shareSupply == 0 ? amount : amount.mul(shareSupply).div(total);\n\n        require(\n            shareSupply.add(share) >= MINIMUM_SUPPLY,\n            \"Insufficient share supply\"\n        );\n\n        emit Deposit(msg.sender, amount, share);\n\n        _mint(msg.sender, share);\n    }\n\n    /**\n     * @notice Withdraws ETH from vault using vault shares\n     * @param share is the number of vault shares to be burned\n     */\n    function withdrawETH(uint256 share) external nonReentrant {\n        require(asset == WETH, \"!WETH\");\n        uint256 withdrawAmount = _withdraw(share, true);\n\n        IWETH(WETH).withdraw(withdrawAmount);\n        (bool success, ) = msg.sender.call{value: withdrawAmount}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    /**\n     * @notice Withdraws WETH from vault using vault shares\n     * @param share is the number of vault shares to be burned\n     */\n    function withdraw(uint256 share) external nonReentrant {\n        uint256 withdrawAmount = _withdraw(share, true);\n        IERC20(asset).safeTransfer(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Withdraws yvWETH + WETH (if necessary) from vault using vault shares\n     * @param share is the number of vault shares to be burned\n     */\n    function withdrawYieldToken(uint256 share) external nonReentrant {\n        uint256 pricePerYearnShare = collateralToken.pricePerShare();\n        uint256 withdrawAmount =\n            wdiv(\n                _withdraw(share, false),\n                pricePerYearnShare.mul(_decimalShift())\n            );\n\n        uint256 yieldTokenBalance = _withdrawYieldToken(withdrawAmount);\n\n        // If there is not enough yvWETH in the vault, it withdraws as much as possible and\n        // transfers the rest in `asset`\n        if (withdrawAmount > yieldTokenBalance) {\n            _withdrawSupplementaryAssetToken(\n                withdrawAmount,\n                yieldTokenBalance,\n                pricePerYearnShare\n            );\n        }\n    }\n\n    /**\n     * @notice Withdraws yvWETH from vault\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     */\n    function _withdrawYieldToken(uint256 withdrawAmount)\n        private\n        returns (uint256 yieldTokenBalance)\n    {\n        yieldTokenBalance = IERC20(address(collateralToken)).balanceOf(\n            address(this)\n        );\n        uint256 yieldTokensToWithdraw = min(yieldTokenBalance, withdrawAmount);\n        if (yieldTokensToWithdraw > 0) {\n            IERC20(address(collateralToken)).safeTransfer(\n                msg.sender,\n                yieldTokensToWithdraw\n            );\n        }\n    }\n\n    /**\n     * @notice Withdraws `asset` from vault\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     * @param yieldTokenBalance is the collateral token (yvWETH) balance of the vault\n     * @param pricePerYearnShare is the yvWETH<->WETH price ratio\n     */\n    function _withdrawSupplementaryAssetToken(\n        uint256 withdrawAmount,\n        uint256 yieldTokenBalance,\n        uint256 pricePerYearnShare\n    ) private {\n        uint256 underlyingTokensToWithdraw =\n            wmul(\n                withdrawAmount.sub(yieldTokenBalance),\n                pricePerYearnShare.mul(_decimalShift())\n            );\n\n        require(\n            IERC20(asset).balanceOf(address(this)) >=\n                underlyingTokensToWithdraw,\n            \"Not enough of `asset` balance to withdraw!\"\n        );\n\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(underlyingTokensToWithdraw);\n            (bool success, ) =\n                msg.sender.call{value: underlyingTokensToWithdraw}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(asset).safeTransfer(msg.sender, underlyingTokensToWithdraw);\n        }\n    }\n\n    /**\n     * @notice Burns vault shares, checks if eligible for withdrawal,\n     * and unwraps yvWETH if necessary\n     * @param share is the number of vault shares to be burned\n     * @param unwrap is whether we want to unwrap to underlying asset\n     */\n    function _withdraw(uint256 share, bool unwrap) private returns (uint256) {\n        (uint256 amountAfterFee, uint256 feeAmount) =\n            withdrawAmountWithShares(share);\n\n        emit Withdraw(msg.sender, amountAfterFee, share, feeAmount);\n\n        _burn(msg.sender, share);\n\n        _unwrapYieldToken(unwrap ? amountAfterFee.add(feeAmount) : feeAmount);\n\n        IERC20(asset).safeTransfer(feeRecipient, feeAmount);\n\n        return amountAfterFee;\n    }\n\n    /**\n     * @notice Unwraps the necessary amount of the yield-bearing yearn token\n     *         and transfers amount to vault\n     * @param amount is the amount of `asset` to withdraw\n     */\n    function _unwrapYieldToken(uint256 amount) private {\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n        uint256 amountToUnwrap =\n            wdiv(\n                max(assetBalance, amount).sub(assetBalance),\n                collateralToken.pricePerShare().mul(_decimalShift())\n            );\n        amountToUnwrap = amountToUnwrap.add(\n            amountToUnwrap.mul(YEARN_WITHDRAWAL_BUFFER).div(10000)\n        );\n        if (amountToUnwrap > 0) {\n            collateralToken.withdraw(\n                amountToUnwrap,\n                address(this),\n                YEARN_WITHDRAWAL_SLIPPAGE\n            );\n        }\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external onlyManager nonReentrant {\n        _setNextOption(optionTerms);\n        _closeShort();\n    }\n\n    function closeShort() external nonReentrant {\n        _closeShort();\n    }\n\n    /**\n     * @notice Sets the next option address and the timestamp at which the\n     * admin can call `rollToNextOption` to open a short for the option.\n     * @param optionTerms is the terms of the option contract\n     */\n    function _setNextOption(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) private {\n        if (isPut) {\n            require(\n                optionTerms.optionType == ProtocolAdapterTypes.OptionType.Put,\n                \"!put\"\n            );\n        } else {\n            require(\n                optionTerms.optionType == ProtocolAdapterTypes.OptionType.Call,\n                \"!call\"\n            );\n        }\n\n        address option = adapter.getOptionsAddress(optionTerms);\n        require(option != address(0), \"!option\");\n        OtokenInterface otoken = OtokenInterface(option);\n        require(otoken.isPut() == isPut, \"Option type does not match\");\n        require(\n            otoken.underlyingAsset() == underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(\n            otoken.collateralAsset() == address(collateralToken),\n            \"Wrong collateralAsset\"\n        );\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp.add(delay);\n        require(\n            otoken.expiryTimestamp() >= readyAt,\n            \"Option expiry cannot be before delay\"\n        );\n\n        nextOption = option;\n        nextOptionReadyAt = readyAt;\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort() private {\n        address oldOption = currentOption;\n        currentOption = address(0);\n        lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            OtokenInterface otoken = OtokenInterface(oldOption);\n            require(\n                block.timestamp > otoken.expiryTimestamp(),\n                \"Cannot close short before expiry\"\n            );\n            uint256 withdrawAmount = adapter.delegateCloseShort();\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyManager nonReentrant {\n        require(\n            block.timestamp >= nextOptionReadyAt,\n            \"Cannot roll before delay\"\n        );\n\n        address newOption = nextOption;\n        require(newOption != address(0), \"No found option\");\n\n        currentOption = newOption;\n        nextOption = address(0);\n\n        uint256 amountToWrap = IERC20(asset).balanceOf(address(this));\n\n        IERC20(asset).safeApprove(address(collateralToken), amountToWrap);\n\n        // there is a slight imprecision with regards to calculating back from yearn token -> underlying\n        // that stems from miscoordination between ytoken .deposit() amount wrapped and pricePerShare\n        // at that point in time.\n        // ex: if I have 1 eth, deposit 1 eth into yearn vault and calculate value of yearn token balance\n        // denominated in eth (via balance(yearn token) * pricePerShare) we will get 1 eth - 1 wei.\n        collateralToken.deposit(amountToWrap, address(this));\n\n        uint256 currentBalance = assetBalance();\n        uint256 shortAmount =\n            wdiv(\n                wmul(currentBalance, lockedRatio),\n                collateralToken.pricePerShare().mul(_decimalShift())\n            );\n        lockedAmount = shortAmount;\n\n        OtokenInterface otoken = OtokenInterface(newOption);\n\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                underlying,\n                USDC,\n                address(collateralToken),\n                otoken.expiryTimestamp(),\n                otoken.strikePrice().mul(10**10), // scale back to 10**18\n                isPut\n                    ? ProtocolAdapterTypes.OptionType.Put\n                    : ProtocolAdapterTypes.OptionType.Call, // isPut\n                address(0)\n            );\n\n        uint256 shortBalance =\n            adapter.delegateCreateShort(optionTerms, shortAmount);\n        IERC20 optionToken = IERC20(newOption);\n        optionToken.safeApprove(address(SWAP_CONTRACT), shortBalance);\n\n        emit OpenShort(newOption, shortAmount, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw from the options protocol by closing short in an event of a emergency\n     */\n    function emergencyWithdrawFromShort() external onlyManager nonReentrant {\n        address oldOption = currentOption;\n        require(oldOption != address(0), \"!currentOption\");\n\n        currentOption = address(0);\n        nextOption = address(0);\n        lockedAmount = 0;\n\n        uint256 withdrawAmount = adapter.delegateCloseShort();\n        emit CloseShort(oldOption, withdrawAmount, msg.sender);\n    }\n\n    /**\n     * @notice Performs a swap of `currentOption` token to `asset` token with a counterparty\n     * @param order is an Airswap order\n     */\n    function sellOptions(Types.Order calldata order) external onlyManager {\n        require(\n            order.sender.wallet == address(this),\n            \"Sender can only be vault\"\n        );\n        require(\n            order.sender.token == currentOption,\n            \"Can only sell currentOption\"\n        );\n        require(order.signer.token == asset, \"Can only buy with asset token\");\n\n        SWAP_CONTRACT.swap(order);\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyManager {\n        uint256 oldCap = cap;\n        cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /**\n     * @notice Closes the vault and makes it withdraw only.\n     */\n    function sunset(address upgradeTo) external onlyOwner {\n        require(upgradeTo != address(0), \"!upgradeTo\");\n\n        replacementVault = IRibbonV2Vault(upgradeTo);\n\n        emit VaultSunset(upgradeTo);\n    }\n\n    /*\n     * @notice Moves msg.sender's deposited funds to new vault w/o fees\n     */\n    function migrate() external nonReentrant {\n        IRibbonV2Vault vault = replacementVault;\n        require(address(vault) != address(0), \"Not sunset\");\n\n        uint256 maxShares = maxWithdrawableShares();\n        uint256 share = balanceOf(msg.sender);\n        uint256 allShares = min(maxShares, share);\n\n        (uint256 withdrawAmount, uint256 feeAmount) =\n            withdrawAmountWithShares(allShares);\n\n        // Since we want to exclude fees, we add them both together\n        withdrawAmount = withdrawAmount.add(feeAmount);\n\n        emit Migrate(msg.sender, address(vault), allShares, withdrawAmount);\n\n        _burn(msg.sender, allShares);\n\n        _unwrapYieldToken(withdrawAmount);\n\n        IERC20(asset).safeApprove(address(vault), withdrawAmount);\n\n        vault.depositFor(withdrawAmount, msg.sender);\n    }\n\n    /**\n     * @notice Returns the expiry of the current option the vault is shorting\n     */\n    function currentOptionExpiry() external view returns (uint256) {\n        address _currentOption = currentOption;\n        if (_currentOption == address(0)) {\n            return 0;\n        }\n\n        OtokenInterface oToken = OtokenInterface(currentOption);\n        return oToken.expiryTimestamp();\n    }\n\n    /**\n     * @notice Returns the amount withdrawable (in `asset` tokens) using the `share` amount\n     * @param share is the number of shares burned to withdraw asset from the vault\n     * @return amountAfterFee is the amount of asset tokens withdrawable from the vault\n     * @return feeAmount is the fee amount (in asset tokens) sent to the feeRecipient\n     */\n    function withdrawAmountWithShares(uint256 share)\n        public\n        view\n        returns (uint256 amountAfterFee, uint256 feeAmount)\n    {\n        uint256 currentAssetBalance = assetBalance();\n        (\n            uint256 withdrawAmount,\n            uint256 newAssetBalance,\n            uint256 newShareSupply\n        ) = _withdrawAmountWithShares(share, currentAssetBalance);\n\n        require(\n            withdrawAmount <= currentAssetBalance,\n            \"Cannot withdraw more than available\"\n        );\n\n        require(newShareSupply >= MINIMUM_SUPPLY, \"Insufficient share supply\");\n        require(\n            newAssetBalance >= MINIMUM_SUPPLY,\n            \"Insufficient asset balance\"\n        );\n\n        feeAmount = wmul(withdrawAmount, instantWithdrawalFee);\n        amountAfterFee = withdrawAmount.sub(feeAmount);\n    }\n\n    /**\n     * @notice Helper function to return the `asset` amount returned using the `share` amount\n     * @param share is the number of shares used to withdraw\n     * @param currentAssetBalance is the value returned by totalBalance(). This is passed in to save gas.\n     */\n    function _withdrawAmountWithShares(\n        uint256 share,\n        uint256 currentAssetBalance\n    )\n        private\n        view\n        returns (\n            uint256 withdrawAmount,\n            uint256 newAssetBalance,\n            uint256 newShareSupply\n        )\n    {\n        uint256 total =\n            wmul(\n                lockedAmount,\n                collateralToken.pricePerShare().mul(_decimalShift())\n            )\n                .add(currentAssetBalance);\n\n        uint256 shareSupply = totalSupply();\n\n        // solhint-disable-next-line\n        // Following the pool share calculation from Alpha Homora: https://github.com/AlphaFinanceLab/alphahomora/blob/340653c8ac1e9b4f23d5b81e61307bf7d02a26e8/contracts/5/Bank.sol#L111\n        withdrawAmount = share.mul(total).div(shareSupply);\n        newAssetBalance = total.sub(withdrawAmount);\n        newShareSupply = shareSupply.sub(share);\n    }\n\n    /**\n     * @notice Returns the max withdrawable shares for all users in the vault\n     */\n    function maxWithdrawableShares() public view returns (uint256) {\n        uint256 withdrawableBalance = assetBalance();\n        uint256 total =\n            wmul(\n                lockedAmount,\n                collateralToken.pricePerShare().mul(_decimalShift())\n            )\n                .add(withdrawableBalance);\n        return\n            withdrawableBalance.mul(totalSupply()).div(total).sub(\n                MINIMUM_SUPPLY\n            );\n    }\n\n    /**\n     * @notice Returns the max amount withdrawable by an account using the account's vault share balance\n     * @param account is the address of the vault share holder\n     * @return amount of `asset` withdrawable from vault, with fees accounted\n     */\n    function maxWithdrawAmount(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 maxShares = maxWithdrawableShares();\n        uint256 share = balanceOf(account);\n        uint256 numShares = min(maxShares, share);\n\n        (uint256 withdrawAmount, , ) =\n            _withdrawAmountWithShares(numShares, assetBalance());\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Returns the number of shares for a given `assetAmount`.\n     *         Used by the frontend to calculate withdraw amounts.\n     * @param assetAmount is the asset amount to be withdrawn\n     * @return share amount\n     */\n    function assetAmountToShares(uint256 assetAmount)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 total =\n            wmul(\n                lockedAmount,\n                collateralToken.pricePerShare().mul(_decimalShift())\n            )\n                .add(assetBalance());\n        return assetAmount.mul(totalSupply()).div(total);\n    }\n\n    /**\n     * @notice Returns an account's balance on the vault\n     * @param account is the address of the user\n     * @return vault balance of the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        (uint256 withdrawAmount, , ) =\n            _withdrawAmountWithShares(balanceOf(account), assetBalance());\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            wmul(\n                lockedAmount,\n                collateralToken.pricePerShare().mul(_decimalShift())\n            )\n                .add(assetBalance());\n    }\n\n    /**\n     * @notice Returns the asset balance on the vault. This balance is freely withdrawable by users.\n     */\n    function assetBalance() public view returns (uint256) {\n        return\n            IERC20(asset).balanceOf(address(this)).add(\n                wmul(\n                    IERC20(address(collateralToken)).balanceOf(address(this)),\n                    collateralToken.pricePerShare().mul(_decimalShift())\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the collateral balance on the vault.\n     */\n    function yearnTokenBalance() public view returns (uint256) {\n        return\n            IERC20(address(collateralToken)).balanceOf(address(this)).add(\n                lockedAmount\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice Returns the decimal shift between 18 decimals and asset tokens\n     */\n    function _decimalShift() private view returns (uint256) {\n        return 10**(uint256(18).sub(collateralToken.decimals()));\n    }\n\n    /**\n     * @notice Only allows manager to execute a function\n     */\n    modifier onlyManager {\n        require(msg.sender == manager, \"Only manager\");\n        _;\n    }\n}\n"
    },
    "contracts/lib/CustomSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        require(token.transfer(to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        require(token.transferFrom(from, to, value));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(token.approve.selector, spender, value)\n            )\n        ) {\n            return;\n        }\n        require(\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\n            ) &&\n                _callOptionalReturn(\n                    token,\n                    abi.encodeWithSelector(\n                        token.approve.selector,\n                        spender,\n                        value\n                    )\n                ),\n            \"ERC20 approve failed\"\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data)\n        private\n        returns (bool)\n    {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        if (!success) {\n            return false;\n        }\n\n        if (returndata.length >= 32) {\n            // Return data is optional\n            return abi.decode(returndata, (bool));\n        }\n\n        // In a wierd case when return data is 1-31 bytes long - return false.\n        return returndata.length == 0;\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256);\n\n    function deposit(uint256 _amount, address _recipient)\n        external\n        returns (uint256);\n\n    function withdraw(\n        uint256 _maxShares,\n        address _recipient,\n        uint256 _maxLoss\n    ) external returns (uint256);\n\n    function approve(address _recipient, uint256 _amount)\n        external\n        returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface IYearnRegistry {\n    function latestVault(address token) external returns (address);\n}\n\ninterface IYearnPricer {\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp) external;\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: Apache\n/*\n  Copyright 2020 Swap Holdings Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity ^0.7.2;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Types: Library of Swap Protocol Types and Hashes\n */\nlibrary Types {\n    struct Order {\n        uint256 nonce; // Unique per order and should be sequential\n        uint256 expiry; // Expiry in seconds since 1 January 1970\n        Party signer; // Party to the trade that sets terms\n        Party sender; // Party to the trade that accepts terms\n        Party affiliate; // Party compensated for facilitating (optional)\n        Signature signature; // Signature of the order\n    }\n\n    struct Party {\n        bytes4 kind; // Interface ID of the token\n        address wallet; // Wallet address of the party\n        address token; // Contract address of the token\n        uint256 amount; // Amount for ERC-20 or ERC-1155\n        uint256 id; // ID for ERC-721 or ERC-1155\n    }\n\n    struct Signature {\n        address signatory; // Address of the wallet used to sign\n        address validator; // Address of the intended swap contract\n        bytes1 version; // EIP-191 signature version\n        uint8 v; // `v` value of an ECDSA signature\n        bytes32 r; // `r` value of an ECDSA signature\n        bytes32 s; // `s` value of an ECDSA signature\n    }\n}\n\ninterface ISwap {\n    event Swap(\n        uint256 indexed nonce,\n        uint256 timestamp,\n        address indexed signerWallet,\n        uint256 signerAmount,\n        uint256 signerId,\n        address signerToken,\n        address indexed senderWallet,\n        uint256 senderAmount,\n        uint256 senderId,\n        address senderToken,\n        address affiliateWallet,\n        uint256 affiliateAmount,\n        uint256 affiliateId,\n        address affiliateToken\n    );\n\n    event Cancel(uint256 indexed nonce, address indexed signerWallet);\n\n    event CancelUpTo(uint256 indexed nonce, address indexed signerWallet);\n\n    event AuthorizeSender(\n        address indexed authorizerAddress,\n        address indexed authorizedSender\n    );\n\n    event AuthorizeSigner(\n        address indexed authorizerAddress,\n        address indexed authorizedSigner\n    );\n\n    event RevokeSender(\n        address indexed authorizerAddress,\n        address indexed revokedSender\n    );\n\n    event RevokeSigner(\n        address indexed authorizerAddress,\n        address indexed revokedSigner\n    );\n\n    /**\n     * @notice Atomic Token Swap\n     * @param order Types.Order\n     */\n    function swap(Types.Order calldata order) external;\n\n    /**\n     * @notice Cancel one or more open orders by nonce\n     * @param nonces uint256[]\n     */\n    function cancel(uint256[] calldata nonces) external;\n\n    /**\n     * @notice Cancels all orders below a nonce value\n     * @dev These orders can be made active by reducing the minimum nonce\n     * @param minimumNonce uint256\n     */\n    function cancelUpTo(uint256 minimumNonce) external;\n\n    /**\n     * @notice Authorize a delegated sender\n     * @param authorizedSender address\n     */\n    function authorizeSender(address authorizedSender) external;\n\n    /**\n     * @notice Authorize a delegated signer\n     * @param authorizedSigner address\n     */\n    function authorizeSigner(address authorizedSigner) external;\n\n    /**\n     * @notice Revoke an authorization\n     * @param authorizedSender address\n     */\n    function revokeSender(address authorizedSender) external;\n\n    /**\n     * @notice Revoke an authorization\n     * @param authorizedSigner address\n     */\n    function revokeSigner(address authorizedSigner) external;\n\n    function senderAuthorizations(address, address)\n        external\n        view\n        returns (bool);\n\n    function signerAuthorizations(address, address)\n        external\n        view\n        returns (bool);\n\n    function signerNonceStatus(address, uint256) external view returns (bytes1);\n\n    function signerMinimumNonce(address) external view returns (uint256);\n\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/interfaces/GammaInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nlibrary GammaTypes {\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\n        // in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n}\n\ninterface OtokenInterface {\n    function addressBook() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external;\n\n    function mintOtoken(address account, uint256 amount) external;\n\n    function burnOtoken(address account, uint256 amount) external;\n}\n\ninterface IOtokenFactory {\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n\n    function oTokens(uint256 index) external returns (address);\n\n    function getOtokensLength() external view returns (uint256);\n\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address);\n}\n\ninterface IController {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets\n        // but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    function getPayout(address _otoken, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function operate(ActionArgs[] calldata _actions) external;\n\n    function getAccountVaultCounter(address owner)\n        external\n        view\n        returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function getVault(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (GammaTypes.Vault memory);\n\n    function getProceed(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (uint256);\n\n    function isSettlementAllowed(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool);\n}\n\ninterface OracleInterface {\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (bool);\n\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (bool);\n\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (uint256, bool);\n\n    function getDisputer() external view returns (address);\n\n    function getPricer(address _asset) external view returns (address);\n\n    function getPrice(address _asset) external view returns (uint256);\n\n    function getPricerLockingPeriod(address _pricer)\n        external\n        view\n        returns (uint256);\n\n    function getPricerDisputePeriod(address _pricer)\n        external\n        view\n        returns (uint256);\n\n    // Non-view function\n\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external;\n\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external;\n\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function setDisputer(address _disputer) external;\n}\n\ninterface MarginCalculatorInterface {\n    function addressBook() external view returns (address);\n\n    function getExpiredPayoutRate(address _otoken)\n        external\n        view\n        returns (uint256);\n\n    function getExcessCollateral(GammaTypes.Vault calldata _vault)\n        external\n        view\n        returns (uint256 netValue, bool isExcess);\n}\n\ninterface IGammaWhitelist {\n    function whitelistCollateral(address _collateral) external;\n\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n}\n"
    },
    "contracts/storage/OptionsVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IRibbonV2Vault} from \"../interfaces/IRibbonVaults.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\n\ncontract OptionsVaultStorageV1 is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    // DEPRECATED: This variable was originally used to store the asset address we are using as collateral\n    // But due to gas optimization and upgradeability security concerns,\n    // we removed it in favor of using immutable variables\n    // This variable is left here to hold the storage slot for upgrades\n    address private _oldAsset;\n\n    // Privileged role that is able to select the option terms (strike price, expiry) to short\n    address public manager;\n\n    // Option that the vault is shorting in the next cycle\n    address public nextOption;\n\n    // The timestamp when the `nextOption` can be used by the vault\n    uint256 public nextOptionReadyAt;\n\n    // Option that the vault is currently shorting\n    address public currentOption;\n\n    // Amount that is currently locked for selling options\n    uint256 public lockedAmount;\n\n    // Cap for total amount deposited into vault\n    uint256 public cap;\n\n    // Fee incurred when withdrawing out of the vault, in the units of 10**18\n    // where 1 ether = 100%, so 0.005 means 0.5% fee\n    uint256 public instantWithdrawalFee;\n\n    // Recipient for withdrawal fees\n    address public feeRecipient;\n}\n\ncontract OptionsVaultStorageV2 {\n    // DEPRECATED FOR V2\n    // Amount locked for scheduled withdrawals\n    uint256 private queuedWithdrawShares;\n\n    // DEPRECATED FOR V2\n    // Mapping to store the scheduled withdrawals (address => withdrawAmount)\n    mapping(address => uint256) private scheduledWithdrawals;\n}\n\ncontract OptionsVaultStorageV3 {\n    // Contract address of replacement\n    IRibbonV2Vault public replacementVault;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of OptionsVaultStorage\n// e.g. OptionsVaultStorageV<versionNumber>, so finally it would look like\n// contract OptionsVaultStorage is OptionsVaultStorageV1, OptionsVaultStorageV2\ncontract OptionsVaultStorage is\n    OptionsVaultStorageV1,\n    OptionsVaultStorageV2,\n    OptionsVaultStorageV3\n{\n\n}\n"
    },
    "contracts/interfaces/IRibbonVaults.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IRibbonV2Vault {\n    function depositFor(uint256 amount, address creditor) external;\n}\n\ninterface IRibbonV1Vault {\n    function deposit(uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IVaultRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IVaultRegistry {\n    function canWithdrawForFree(address fromVault, address toVault)\n        external\n        returns (bool);\n\n    function canCrossTrade(address longVault, address shortVault)\n        external\n        returns (bool);\n}\n"
    },
    "contracts/instruments/RibbonThetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\n\nimport {\n    ProtocolAdapterTypes,\n    IProtocolAdapter\n} from \"../adapters/IProtocolAdapter.sol\";\nimport {ProtocolAdapter} from \"../adapters/ProtocolAdapter.sol\";\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\nimport {IRibbonV2Vault, IRibbonV1Vault} from \"../interfaces/IRibbonVaults.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {ISwap, Types} from \"../interfaces/ISwap.sol\";\nimport {OtokenInterface} from \"../interfaces/GammaInterface.sol\";\nimport {OptionsVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\n\ncontract RibbonThetaVault is DSMath, OptionsVaultStorage {\n    using ProtocolAdapter for IProtocolAdapter;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    string private constant _adapterName = \"OPYN_GAMMA\";\n\n    IProtocolAdapter public immutable adapter;\n    IVaultRegistry public immutable registry;\n    address public immutable asset;\n    address public immutable underlying;\n    address public immutable WETH;\n    address public immutable USDC;\n    bool public immutable isPut;\n    uint8 private immutable _decimals;\n\n    // AirSwap Swap contract\n    // https://github.com/airswap/airswap-protocols/blob/master/source/swap/contracts/interfaces/ISwap.sol\n    ISwap public immutable SWAP_CONTRACT;\n\n    // 100% locked in options protocol, 0% of the pool reserved for withdrawals\n    uint256 public constant lockedRatio = 1 ether;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public immutable MINIMUM_SUPPLY;\n\n    event ManagerChanged(address oldManager, address newManager);\n\n    event Deposit(address indexed account, uint256 amount, uint256 share);\n\n    event Withdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 share,\n        uint256 fee\n    );\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event WithdrawalFeeSet(uint256 oldFee, uint256 newFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event VaultSunset(address replacement);\n\n    event WithdrawToV1Vault(\n        address account,\n        uint256 oldShares,\n        address to,\n        uint256 newShares\n    );\n\n    event Migrate(\n        address account,\n        address replacement,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _asset is the asset used for collateral and premiums\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _swapContract is the Airswap Swap contract\n     * @param _tokenDecimals is the decimals for the vault shares. Must match the decimals for _asset.\n     * @param _minimumSupply is the minimum supply for the asset balance and the share supply.\n     * It's important to bake the _factory variable into the contract with the constructor\n     * If we do it in the `initialize` function, users get to set the factory variable and\n     * subsequently the adapter, which allows them to make a delegatecall, then selfdestruct the contract.\n     */\n    constructor(\n        address _asset,\n        address _factory,\n        address _registry,\n        address _weth,\n        address _usdc,\n        address _swapContract,\n        uint8 _tokenDecimals,\n        uint256 _minimumSupply,\n        bool _isPut\n    ) {\n        require(_asset != address(0), \"!_asset\");\n        require(_factory != address(0), \"!_factory\");\n        require(_registry != address(0), \"!_registry\");\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_swapContract != address(0), \"!_swapContract\");\n        require(_tokenDecimals > 0, \"!_tokenDecimals\");\n        require(_minimumSupply > 0, \"!_minimumSupply\");\n\n        IRibbonFactory factoryInstance = IRibbonFactory(_factory);\n        address adapterAddr = factoryInstance.getAdapter(_adapterName);\n        require(adapterAddr != address(0), \"Adapter not set\");\n\n        asset = _isPut ? _usdc : _asset;\n        underlying = _asset;\n        adapter = IProtocolAdapter(adapterAddr);\n        registry = IVaultRegistry(_registry);\n        WETH = _weth;\n        USDC = _usdc;\n        SWAP_CONTRACT = ISwap(_swapContract);\n        _decimals = _tokenDecimals;\n        MINIMUM_SUPPLY = _minimumSupply;\n        isPut = _isPut;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _owner is the owner of the contract who can set the manager\n     * @param _feeRecipient is the recipient address for withdrawal fees.\n     * @param _initCap is the initial vault's cap on deposits, the manager can increase this as necessary.\n     * @param _tokenName is the name of the vault share token\n     * @param _tokenSymbol is the symbol of the vault share token\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _initCap,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external initializer {\n        require(_owner != address(0), \"!_owner\");\n        require(_feeRecipient != address(0), \"!_feeRecipient\");\n        require(_initCap > 0, \"_initCap > 0\");\n        require(bytes(_tokenName).length > 0, \"_tokenName != 0x\");\n        require(bytes(_tokenSymbol).length > 0, \"_tokenSymbol != 0x\");\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n        cap = _initCap;\n\n        // hardcode the initial withdrawal fee\n        instantWithdrawalFee = 0.005 ether;\n        feeRecipient = _feeRecipient;\n    }\n\n    /**\n     * @notice Closes the vault and makes it withdraw only.\n     */\n    function sunset(address upgradeTo) external onlyOwner {\n        require(upgradeTo != address(0), \"!upgradeTo\");\n\n        replacementVault = IRibbonV2Vault(upgradeTo);\n\n        emit VaultSunset(upgradeTo);\n    }\n\n    /**\n     * @notice Sets the new manager of the vault.\n     * @param newManager is the new manager of the vault\n     */\n    function setManager(address newManager) external onlyOwner {\n        require(newManager != address(0), \"!newManager\");\n        address oldManager = manager;\n        manager = newManager;\n\n        emit ManagerChanged(oldManager, newManager);\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the new withdrawal fee\n     * @param newWithdrawalFee is the fee paid in tokens when withdrawing\n     */\n    function setWithdrawalFee(uint256 newWithdrawalFee) external onlyManager {\n        require(newWithdrawalFee > 0, \"withdrawalFee != 0\");\n\n        // cap max withdrawal fees to 30% of the withdrawal amount\n        require(newWithdrawalFee < 0.3 ether, \"withdrawalFee >= 30%\");\n\n        uint256 oldFee = instantWithdrawalFee;\n        emit WithdrawalFeeSet(oldFee, newWithdrawalFee);\n\n        instantWithdrawalFee = newWithdrawalFee;\n    }\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the underlying is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(asset == WETH, \"asset is not WETH\");\n        require(msg.value > 0, \"No value passed\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }\n\n    /**\n     * @notice Deposits the `asset` into the contract and mint vault shares.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        _deposit(amount);\n    }\n\n    /**\n     * @notice Mints the vault shares to the msg.sender\n     * @param amount is the amount of `asset` deposited\n     */\n    function _deposit(uint256 amount) private {\n        uint256 totalWithDepositedAmount = totalBalance();\n        require(totalWithDepositedAmount < cap, \"Cap exceeded\");\n        require(\n            totalWithDepositedAmount >= MINIMUM_SUPPLY,\n            \"Insufficient asset balance\"\n        );\n\n        // amount needs to be subtracted from totalBalance because it has already been\n        // added to it from either IWETH.deposit and IERC20.safeTransferFrom\n        uint256 total = totalWithDepositedAmount.sub(amount);\n\n        uint256 shareSupply = totalSupply();\n\n        // Following the pool share calculation from Alpha Homora:\n        // solhint-disable-next-line\n        // https://github.com/AlphaFinanceLab/alphahomora/blob/340653c8ac1e9b4f23d5b81e61307bf7d02a26e8/contracts/5/Bank.sol#L104\n        uint256 share =\n            shareSupply == 0 ? amount : amount.mul(shareSupply).div(total);\n\n        require(\n            shareSupply.add(share) >= MINIMUM_SUPPLY,\n            \"Insufficient share supply\"\n        );\n\n        emit Deposit(msg.sender, amount, share);\n\n        _mint(msg.sender, share);\n    }\n\n    /**\n     * @notice Withdraws ETH from vault using vault shares\n     * @param share is the number of vault shares to be burned\n     */\n    function withdrawETH(uint256 share) external nonReentrant {\n        require(asset == WETH, \"!WETH\");\n        uint256 withdrawAmount = _withdraw(share, false);\n\n        IWETH(WETH).withdraw(withdrawAmount);\n        (bool success, ) = msg.sender.call{value: withdrawAmount}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    /**\n     * @notice Withdraws WETH from vault using vault shares\n     * @param share is the number of vault shares to be burned\n     */\n    function withdraw(uint256 share) external nonReentrant {\n        uint256 withdrawAmount = _withdraw(share, false);\n        IERC20(asset).safeTransfer(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Withdraw from V1 vault to V1 vault\n     * @notice Waive fee if registered in vault registry\n     * @param share is the number of vault shares to be burned\n     * @param vault is the address of destination V1 vault\n     */\n    function withdrawToV1Vault(uint256 share, address vault)\n        external\n        nonReentrant\n    {\n        require(vault != address(0), \"!vault\");\n        require(share > 0, \"!share\");\n\n        bool feeless = registry.canWithdrawForFree(address(this), vault);\n        require(feeless, \"Feeless withdraw to vault not allowed\");\n\n        uint256 withdrawAmount = _withdraw(share, feeless);\n\n        // Send assets to new vault rather than user\n        IERC20(asset).safeApprove(vault, withdrawAmount);\n        IRibbonV1Vault(vault).deposit(withdrawAmount);\n        uint256 receivedShares = IERC20(vault).balanceOf(address(this));\n        IERC20(vault).safeTransfer(msg.sender, receivedShares);\n\n        emit WithdrawToV1Vault(msg.sender, share, vault, receivedShares);\n    }\n\n    /**\n     * @notice Burns vault shares and checks if eligible for withdrawal\n     * @param share is the number of vault shares to be burned\n     * @param feeless is whether a withdraw fee is charged\n     */\n    function _withdraw(uint256 share, bool feeless) private returns (uint256) {\n        (uint256 amountAfterFee, uint256 feeAmount) =\n            withdrawAmountWithShares(share);\n\n        if (feeless) {\n            amountAfterFee = amountAfterFee.add(feeAmount);\n            feeAmount = 0;\n        }\n\n        emit Withdraw(msg.sender, amountAfterFee, share, feeAmount);\n\n        _burn(msg.sender, share);\n\n        IERC20(asset).safeTransfer(feeRecipient, feeAmount);\n\n        return amountAfterFee;\n    }\n\n    /*\n     * @notice Moves msg.sender's deposited funds to new vault w/o fees\n     */\n    function migrate() external nonReentrant {\n        IRibbonV2Vault vault = replacementVault;\n        require(address(vault) != address(0), \"Not sunset\");\n\n        uint256 maxShares = maxWithdrawableShares();\n        uint256 share = balanceOf(msg.sender);\n        uint256 allShares = min(maxShares, share);\n\n        (uint256 withdrawAmount, uint256 feeAmount) =\n            withdrawAmountWithShares(allShares);\n\n        // Since we want to exclude fees, we add them both together\n        withdrawAmount = withdrawAmount.add(feeAmount);\n\n        emit Migrate(msg.sender, address(vault), allShares, withdrawAmount);\n\n        _burn(msg.sender, allShares);\n\n        IERC20(asset).safeApprove(address(vault), withdrawAmount);\n\n        vault.depositFor(withdrawAmount, msg.sender);\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external onlyManager nonReentrant {\n        _setNextOption(optionTerms);\n        _closeShort();\n    }\n\n    function closeShort() external nonReentrant {\n        _closeShort();\n    }\n\n    /**\n     * @notice Sets the next option address and the timestamp at which the\n     * admin can call `rollToNextOption` to open a short for the option.\n     * @param optionTerms is the terms of the option contract\n     */\n    function _setNextOption(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) private {\n        if (isPut) {\n            require(\n                optionTerms.optionType == ProtocolAdapterTypes.OptionType.Put,\n                \"!put\"\n            );\n        } else {\n            require(\n                optionTerms.optionType == ProtocolAdapterTypes.OptionType.Call,\n                \"!call\"\n            );\n        }\n\n        address option = adapter.getOptionsAddress(optionTerms);\n        require(option != address(0), \"!option\");\n        OtokenInterface otoken = OtokenInterface(option);\n        require(otoken.isPut() == isPut, \"Option type does not match\");\n        require(\n            otoken.underlyingAsset() == underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(otoken.collateralAsset() == asset, \"Wrong collateralAsset\");\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp.add(delay);\n        require(\n            otoken.expiryTimestamp() >= readyAt,\n            \"Option expiry cannot be before delay\"\n        );\n\n        nextOption = option;\n        nextOptionReadyAt = readyAt;\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort() private {\n        address oldOption = currentOption;\n        currentOption = address(0);\n        lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            OtokenInterface otoken = OtokenInterface(oldOption);\n            require(\n                block.timestamp > otoken.expiryTimestamp(),\n                \"Cannot close short before expiry\"\n            );\n            uint256 withdrawAmount = adapter.delegateCloseShort();\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /*\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyManager nonReentrant {\n        require(\n            block.timestamp >= nextOptionReadyAt,\n            \"Cannot roll before delay\"\n        );\n\n        address newOption = nextOption;\n        require(newOption != address(0), \"No found option\");\n\n        currentOption = newOption;\n        nextOption = address(0);\n\n        uint256 currentBalance = assetBalance();\n        uint256 shortAmount = wmul(currentBalance, lockedRatio);\n        lockedAmount = shortAmount;\n\n        OtokenInterface otoken = OtokenInterface(newOption);\n\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                otoken.underlyingAsset(),\n                USDC,\n                otoken.collateralAsset(),\n                otoken.expiryTimestamp(),\n                otoken.strikePrice().mul(10**10), // scale back to 10**18\n                isPut\n                    ? ProtocolAdapterTypes.OptionType.Put\n                    : ProtocolAdapterTypes.OptionType.Call, // isPut\n                address(0)\n            );\n\n        uint256 shortBalance =\n            adapter.delegateCreateShort(optionTerms, shortAmount);\n        IERC20 optionToken = IERC20(newOption);\n        optionToken.safeApprove(address(SWAP_CONTRACT), shortBalance);\n\n        emit OpenShort(newOption, shortAmount, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw from the options protocol by closing short in an event of a emergency\n     */\n    function emergencyWithdrawFromShort() external onlyManager nonReentrant {\n        address oldOption = currentOption;\n        require(oldOption != address(0), \"!currentOption\");\n\n        currentOption = address(0);\n        nextOption = address(0);\n        lockedAmount = 0;\n\n        uint256 withdrawAmount = adapter.delegateCloseShort();\n        emit CloseShort(oldOption, withdrawAmount, msg.sender);\n    }\n\n    /**\n     * @notice Performs a swap of `currentOption` token to `asset` token with a counterparty\n     * @param order is an Airswap order\n     */\n    function sellOptions(Types.Order calldata order) external onlyManager {\n        require(\n            order.sender.wallet == address(this),\n            \"Sender can only be vault\"\n        );\n        require(\n            order.sender.token == currentOption,\n            \"Can only sell currentOption\"\n        );\n        require(order.signer.token == asset, \"Can only buy with asset token\");\n\n        SWAP_CONTRACT.swap(order);\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyManager {\n        uint256 oldCap = cap;\n        cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /**\n     * @notice Returns the expiry of the current option the vault is shorting\n     */\n    function currentOptionExpiry() external view returns (uint256) {\n        address _currentOption = currentOption;\n        if (_currentOption == address(0)) {\n            return 0;\n        }\n\n        OtokenInterface oToken = OtokenInterface(currentOption);\n        return oToken.expiryTimestamp();\n    }\n\n    /**\n     * @notice Returns the amount withdrawable (in `asset` tokens) using the `share` amount\n     * @param share is the number of shares burned to withdraw asset from the vault\n     * @return amountAfterFee is the amount of asset tokens withdrawable from the vault\n     * @return feeAmount is the fee amount (in asset tokens) sent to the feeRecipient\n     */\n    function withdrawAmountWithShares(uint256 share)\n        public\n        view\n        returns (uint256 amountAfterFee, uint256 feeAmount)\n    {\n        uint256 currentAssetBalance = assetBalance();\n        (\n            uint256 withdrawAmount,\n            uint256 newAssetBalance,\n            uint256 newShareSupply\n        ) = _withdrawAmountWithShares(share, currentAssetBalance);\n\n        require(\n            withdrawAmount <= currentAssetBalance,\n            \"Cannot withdraw more than available\"\n        );\n\n        require(newShareSupply >= MINIMUM_SUPPLY, \"Insufficient share supply\");\n        require(\n            newAssetBalance >= MINIMUM_SUPPLY,\n            \"Insufficient asset balance\"\n        );\n\n        feeAmount = wmul(withdrawAmount, instantWithdrawalFee);\n        amountAfterFee = withdrawAmount.sub(feeAmount);\n    }\n\n    /**\n     * @notice Helper function to return the `asset` amount returned using the `share` amount\n     * @param share is the number of shares used to withdraw\n     * @param currentAssetBalance is the value returned by totalBalance(). This is passed in to save gas.\n     */\n    function _withdrawAmountWithShares(\n        uint256 share,\n        uint256 currentAssetBalance\n    )\n        private\n        view\n        returns (\n            uint256 withdrawAmount,\n            uint256 newAssetBalance,\n            uint256 newShareSupply\n        )\n    {\n        uint256 total = lockedAmount.add(currentAssetBalance);\n\n        uint256 shareSupply = totalSupply();\n\n        // solhint-disable-next-line\n        // Following the pool share calculation from Alpha Homora: https://github.com/AlphaFinanceLab/alphahomora/blob/340653c8ac1e9b4f23d5b81e61307bf7d02a26e8/contracts/5/Bank.sol#L111\n        withdrawAmount = share.mul(total).div(shareSupply);\n        newAssetBalance = total.sub(withdrawAmount);\n        newShareSupply = shareSupply.sub(share);\n    }\n\n    /**\n     * @notice Returns the max withdrawable shares for all users in the vault\n     */\n    function maxWithdrawableShares() public view returns (uint256) {\n        uint256 withdrawableBalance = assetBalance();\n        uint256 total = lockedAmount.add(withdrawableBalance);\n        return\n            withdrawableBalance.mul(totalSupply()).div(total).sub(\n                MINIMUM_SUPPLY\n            );\n    }\n\n    /**\n     * @notice Returns the max amount withdrawable by an account using the account's vault share balance\n     * @param account is the address of the vault share holder\n     * @return amount of `asset` withdrawable from vault, with fees accounted\n     */\n    function maxWithdrawAmount(address account) public view returns (uint256) {\n        uint256 maxShares = maxWithdrawableShares();\n        uint256 share = balanceOf(account);\n        uint256 numShares = min(maxShares, share);\n\n        (uint256 withdrawAmount, , ) =\n            _withdrawAmountWithShares(numShares, assetBalance());\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Returns the number of shares for a given `assetAmount`.\n     *         Used by the frontend to calculate withdraw amounts.\n     * @param assetAmount is the asset amount to be withdrawn\n     * @return share amount\n     */\n    function assetAmountToShares(uint256 assetAmount)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 total = lockedAmount.add(assetBalance());\n        return assetAmount.mul(totalSupply()).div(total);\n    }\n\n    /**\n     * @notice Returns an account's balance on the vault\n     * @param account is the address of the user\n     * @return vault balance of the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        (uint256 withdrawAmount, , ) =\n            _withdrawAmountWithShares(balanceOf(account), assetBalance());\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return lockedAmount.add(IERC20(asset).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Returns the asset balance on the vault. This balance is freely withdrawable by users.\n     */\n    function assetBalance() public view returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice Only allows manager to execute a function\n     */\n    modifier onlyManager {\n        require(msg.sender == manager, \"Only manager\");\n        _;\n    }\n}\n"
    },
    "contracts/tests/MockGammaController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router.sol\";\nimport {OtokenInterface, IController} from \"../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\n\ncontract MockGammaController is DSMath {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public price;\n    address public oracle;\n    IUniswapV2Router02 public router;\n    address public weth;\n\n    constructor(\n        address _oracle,\n        IUniswapV2Router02 _router,\n        address _weth\n    ) {\n        oracle = _oracle;\n        router = _router;\n        weth = _weth;\n    }\n\n    function getPayout(address _otoken, uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        OtokenInterface oToken = OtokenInterface(_otoken);\n        uint256 strikePrice = oToken.strikePrice();\n\n        uint256 payout;\n        if (strikePrice >= price) {\n            payout = _amount;\n        } else {\n            payout = (price.sub(strikePrice)).mul(_amount).div(10**8);\n        }\n\n        uint256 collateralDecimals;\n        if (\n            oToken.collateralAsset() ==\n            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n        ) {\n            collateralDecimals = 6;\n            return (payout.mul(10**collateralDecimals)).div(10**8);\n        } else {\n            collateralDecimals = 18;\n            return wdiv(payout, price);\n        }\n    }\n\n    function operate(IController.ActionArgs[] memory actions) public {\n        for (uint256 i = 0; i < actions.length; i++) {\n            IController.ActionArgs memory action = actions[i];\n            if (action.actionType == IController.ActionType.Redeem) {\n                _redeem(_parseRedeemArgs(action));\n            }\n        }\n    }\n\n    function buyCollateral(address otoken) external payable {\n        address collateralAsset = OtokenInterface(otoken).collateralAsset();\n\n        if (collateralAsset == weth) {\n            IWETH wethContract = IWETH(weth);\n            wethContract.deposit{value: msg.value}();\n            return;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = weth;\n        path[1] = collateralAsset;\n\n        uint256[] memory amountsOut = router.getAmountsOut(msg.value, path);\n        uint256 minAmountOut = amountsOut[1];\n\n        router.swapExactETHForTokens{value: msg.value}(\n            minAmountOut,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n\n        require(\n            IERC20(collateralAsset).balanceOf(address(this)) >= minAmountOut,\n            \"Not enough collateral balance\"\n        );\n    }\n\n    function _redeem(IController.RedeemArgs memory _args) internal {\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        require(\n            block.timestamp >= otoken.expiryTimestamp(),\n            \"Controller: can not redeem un-expired otoken\"\n        );\n\n        uint256 payout = getPayout(_args.otoken, _args.amount);\n\n        IERC20 collateralToken = IERC20(otoken.collateralAsset());\n\n        require(\n            collateralToken.balanceOf(address(this)) >= payout,\n            \"Not enough collateral balance to payout\"\n        );\n\n        collateralToken.safeTransfer(_args.receiver, payout);\n    }\n\n    function _parseRedeemArgs(IController.ActionArgs memory _args)\n        internal\n        pure\n        returns (IController.RedeemArgs memory)\n    {\n        require(\n            _args.actionType == IController.ActionType.Redeem,\n            \"Actions: can only parse arguments for redeem actions\"\n        );\n        require(\n            _args.secondAddress != address(0),\n            \"Actions: cannot redeem to an invalid account\"\n        );\n\n        return\n            IController.RedeemArgs({\n                receiver: _args.secondAddress,\n                otoken: _args.asset,\n                amount: _args.amount\n            });\n    }\n\n    function setPrice(uint256 amount) public {\n        price = amount;\n    }\n}\n"
    },
    "contracts/archive/RibbonVolatility.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\nimport {\n    InstrumentStorageV1,\n    InstrumentStorageV2,\n    Venues\n} from \"../storage/InstrumentStorage.sol\";\nimport {\n    ProtocolAdapterTypes,\n    IProtocolAdapter\n} from \"../adapters/IProtocolAdapter.sol\";\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\nimport {ProtocolAdapter} from \"../adapters/ProtocolAdapter.sol\";\nimport {Ownable} from \"../lib/Ownable.sol\";\n\ncontract RibbonVolatility is DSMath, InstrumentStorageV1, InstrumentStorageV2 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using ProtocolAdapter for IProtocolAdapter;\n\n    bytes32 private constant hegicHash = keccak256(bytes(\"HEGIC\"));\n    bytes32 private constant opynHash = keccak256(bytes(\"OPYN_GAMMA\"));\n    bytes32 private constant charmHash = keccak256(bytes(\"CHARM\"));\n\n    event PositionCreated(\n        address indexed account,\n        uint256 indexed positionID,\n        string[] venues,\n        ProtocolAdapterTypes.OptionType[] optionTypes,\n        uint256 amount\n    );\n    event Exercised(\n        address indexed account,\n        uint256 indexed positionID,\n        uint256 totalProfit,\n        bool[] optionsExercised\n    );\n\n    event ClaimedRewards(uint256 numRewards);\n\n    receive() external payable {}\n\n    function initialize(\n        address _owner,\n        address _factory,\n        string memory _name,\n        string memory _symbol,\n        address _underlying,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _expiry\n    ) public initializer {\n        require(block.timestamp < _expiry, \"Expiry has already passed\");\n\n        Ownable.initialize(_owner);\n        factory = IRibbonFactory(_factory);\n        name = _name;\n        symbol = _symbol;\n        expiry = _expiry;\n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n    }\n\n    function exerciseProfit(address account, uint256 positionID)\n        external\n        view\n        returns (uint256)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return 0;\n\n        uint256 profit = 0;\n\n        uint8[] memory venues = new uint8[](2);\n        venues[0] = position.putVenue;\n        venues[1] = position.callVenue;\n\n        for (uint256 i = 0; i < venues.length; i++) {\n            string memory venue = getAdapterName(venues[i]);\n            uint256 amount = position.amount;\n\n            ProtocolAdapterTypes.OptionType optionType;\n            uint256 strikePrice;\n            uint32 optionID;\n            if (i == 0) {\n                strikePrice = position.putStrikePrice;\n                optionID = position.putOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Put;\n            } else {\n                strikePrice = position.callStrikePrice;\n                optionID = position.callOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Call;\n            }\n\n            address adapterAddress = factory.getAdapter(venue);\n            require(adapterAddress != address(0), \"Adapter does not exist\");\n            IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n            address options =\n                adapter.getOptionsAddress(\n                    ProtocolAdapterTypes.OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrice,\n                        optionType,\n                        address(0) // paymentToken is not used at all nor stored in storage\n                    )\n                );\n\n            bool exercisable = adapter.canExercise(options, optionID, amount);\n            if (!exercisable) {\n                continue;\n            }\n\n            profit += adapter.delegateExerciseProfit(options, optionID, amount);\n        }\n        return profit;\n    }\n\n    function canExercise(address account, uint256 positionID)\n        external\n        view\n        returns (bool)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return false;\n\n        bool eitherOneCanExercise = false;\n\n        uint8[] memory venues = new uint8[](2);\n        venues[0] = position.putVenue;\n        venues[1] = position.callVenue;\n\n        for (uint256 i = 0; i < venues.length; i++) {\n            string memory venue = getAdapterName(venues[i]);\n            uint256 strikePrice;\n            uint32 optionID;\n            ProtocolAdapterTypes.OptionType optionType;\n            if (i == 0) {\n                strikePrice = position.putStrikePrice;\n                optionID = position.putOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Put;\n            } else {\n                strikePrice = position.callStrikePrice;\n                optionID = position.callOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Call;\n            }\n\n            address adapterAddress = factory.getAdapter(venue);\n            require(adapterAddress != address(0), \"Adapter does not exist\");\n            IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n\n            address options =\n                adapter.getOptionsAddress(\n                    ProtocolAdapterTypes.OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        address(0), // collateralAsset not needed\n                        expiry,\n                        strikePrice,\n                        optionType,\n                        address(0) // paymentToken is not used nor stored in storage\n                    )\n                );\n\n            bool canExerciseOptions =\n                adapter.canExercise(options, optionID, position.amount);\n\n            if (canExerciseOptions) {\n                eitherOneCanExercise = true;\n            }\n        }\n        return eitherOneCanExercise;\n    }\n\n    struct BuyInstrumentParams {\n        uint8 callVenue;\n        uint8 putVenue;\n        address paymentToken;\n        uint256 callStrikePrice;\n        uint256 putStrikePrice;\n        uint256 amount;\n        uint256 callMaxCost;\n        uint256 putMaxCost;\n        bytes callBuyData;\n        bytes putBuyData;\n    }\n\n    function buyInstrument(BuyInstrumentParams calldata params)\n        external\n        payable\n        nonReentrant\n        returns (uint256 positionID)\n    {\n        require(block.timestamp < expiry, \"Cannot purchase after expiry\");\n\n        factory.burnGasTokens();\n\n        string memory callVenueName = getAdapterName(params.callVenue);\n        string memory putVenueName = getAdapterName(params.putVenue);\n\n        uint32 putOptionID =\n            purchaseOptionAtVenue(\n                putVenueName,\n                ProtocolAdapterTypes.OptionType.Put,\n                params.amount,\n                params.putStrikePrice,\n                params.putBuyData,\n                params.paymentToken,\n                params.putMaxCost\n            );\n        uint32 callOptionID =\n            purchaseOptionAtVenue(\n                callVenueName,\n                ProtocolAdapterTypes.OptionType.Call,\n                params.amount,\n                params.callStrikePrice,\n                params.callBuyData,\n                params.paymentToken,\n                params.callMaxCost\n            );\n\n        InstrumentPosition memory position =\n            InstrumentPosition(\n                false,\n                params.callVenue,\n                params.putVenue,\n                callOptionID,\n                putOptionID,\n                params.amount,\n                params.callStrikePrice,\n                params.putStrikePrice\n            );\n\n        positionID = instrumentPositions[msg.sender].length;\n        instrumentPositions[msg.sender].push(position);\n\n        uint256 balance = address(this).balance;\n        if (balance > 0) payable(msg.sender).transfer(balance);\n    }\n\n    function purchaseOptionAtVenue(\n        string memory venue,\n        ProtocolAdapterTypes.OptionType optionType,\n        uint256 amount,\n        uint256 strikePrice,\n        bytes memory buyData,\n        address paymentToken,\n        uint256 maxCost\n    ) private returns (uint32 optionID) {\n        address adapterAddress = factory.getAdapter(venue);\n        require(adapterAddress != address(0), \"Adapter does not exist\");\n        IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n\n        require(\n            optionType != ProtocolAdapterTypes.OptionType.Invalid,\n            \"Invalid option type\"\n        );\n\n        uint256 _expiry = expiry;\n\n        Venues venueID = getVenueID(venue);\n\n        if (venueID == Venues.OpynGamma) {\n            purchaseWithZeroEx(\n                adapter,\n                optionType,\n                strikePrice,\n                buyData,\n                _expiry\n            );\n        } else if (venueID == Venues.Hegic || venueID == Venues.Charm) {\n            optionID = purchaseWithContract(\n                adapter,\n                optionType,\n                amount,\n                strikePrice,\n                paymentToken,\n                maxCost,\n                _expiry\n            );\n        } else {\n            revert(\"Venue not supported\");\n        }\n    }\n\n    function purchaseWithContract(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionType optionType,\n        uint256 amount,\n        uint256 strikePrice,\n        address paymentToken,\n        uint256 maxCost,\n        uint256 _expiry\n    ) private returns (uint32 optionID) {\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                _expiry,\n                strikePrice,\n                optionType,\n                paymentToken\n            );\n\n        uint256 optionID256 =\n            adapter.delegatePurchase(optionTerms, amount, maxCost);\n        optionID = uint32(optionID256);\n    }\n\n    function purchaseWithZeroEx(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionType optionType,\n        uint256 strikePrice,\n        bytes memory buyData,\n        uint256 _expiry\n    ) private {\n        ProtocolAdapterTypes.OptionTerms memory optionTerms =\n            ProtocolAdapterTypes.OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                _expiry,\n                strikePrice,\n                optionType,\n                address(0)\n            );\n\n        ProtocolAdapterTypes.ZeroExOrder memory zeroExOrder =\n            abi.decode(buyData, (ProtocolAdapterTypes.ZeroExOrder));\n\n        adapter.delegatePurchaseWithZeroEx(optionTerms, zeroExOrder);\n    }\n\n    function exercisePosition(uint256 positionID)\n        external\n        nonReentrant\n        returns (uint256 totalProfit)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[msg.sender][positionID];\n        require(!position.exercised, \"Already exercised\");\n\n        bool[] memory optionsExercised = new bool[](2);\n        uint8[] memory venues = new uint8[](2);\n        venues[0] = position.putVenue;\n        venues[1] = position.callVenue;\n\n        for (uint256 i = 0; i < venues.length; i++) {\n            string memory adapterName = getAdapterName(venues[i]);\n            IProtocolAdapter adapter =\n                IProtocolAdapter(factory.getAdapter(adapterName));\n\n            ProtocolAdapterTypes.OptionType optionType;\n            uint256 strikePrice;\n            uint32 optionID;\n            if (i == 0) {\n                strikePrice = position.putStrikePrice;\n                optionID = position.putOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Put;\n            } else {\n                strikePrice = position.callStrikePrice;\n                optionID = position.callOptionID;\n                optionType = ProtocolAdapterTypes.OptionType.Call;\n            }\n\n            address paymentToken = address(0); // it is irrelevant at this stage\n\n            address optionsAddress =\n                adapter.getOptionsAddress(\n                    ProtocolAdapterTypes.OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrice,\n                        optionType,\n                        paymentToken\n                    )\n                );\n\n            require(optionsAddress != address(0), \"Options address must exist\");\n\n            uint256 amount = position.amount;\n\n            uint256 profit =\n                adapter.delegateExerciseProfit(\n                    optionsAddress,\n                    optionID,\n                    amount\n                );\n            if (profit > 0) {\n                adapter.delegateExercise(\n                    optionsAddress,\n                    optionID,\n                    amount,\n                    msg.sender\n                );\n                optionsExercised[i] = true;\n            } else {\n                optionsExercised[i] = false;\n            }\n            totalProfit += profit;\n        }\n        position.exercised = true;\n\n        emit Exercised(msg.sender, positionID, totalProfit, optionsExercised);\n    }\n\n    function claimRewards(address rewardsAddress) external {\n        IProtocolAdapter adapter =\n            IProtocolAdapter(factory.getAdapter(\"HEGIC\"));\n        uint256[] memory optionIDs = getOptionIDs(msg.sender);\n        uint256 claimedRewards =\n            adapter.delegateClaimRewards(rewardsAddress, optionIDs);\n        emit ClaimedRewards(claimedRewards);\n    }\n\n    function rewardsClaimable(address rewardsAddress)\n        external\n        view\n        returns (uint256 rewardsToClaim)\n    {\n        IProtocolAdapter adapter =\n            IProtocolAdapter(factory.getAdapter(\"HEGIC\"));\n        uint256[] memory optionIDs = getOptionIDs(msg.sender);\n        rewardsToClaim = adapter.delegateRewardsClaimable(\n            rewardsAddress,\n            optionIDs\n        );\n    }\n\n    function getOptionIDs(address user)\n        private\n        view\n        returns (uint256[] memory optionIDs)\n    {\n        uint256 i = 0;\n        uint256 j = 0;\n\n        InstrumentPosition[] memory positions = instrumentPositions[user];\n\n        optionIDs = new uint256[](positions.length.mul(2));\n\n        while (i < positions.length) {\n            if (\n                keccak256(bytes(getAdapterName(positions[i].callVenue))) ==\n                hegicHash\n            ) {\n                optionIDs[j] = positions[i].callOptionID;\n                j += 1;\n            }\n            if (\n                keccak256(bytes(getAdapterName(positions[i].putVenue))) ==\n                hegicHash\n            ) {\n                optionIDs[j] = positions[i].putOptionID;\n                j += 1;\n            }\n            i += 1;\n        }\n    }\n\n    function getAdapterName(uint8 venueID)\n        private\n        pure\n        returns (string memory)\n    {\n        if (venueID == uint8(Venues.Hegic)) {\n            return \"HEGIC\";\n        } else if (venueID == uint8(Venues.OpynGamma)) {\n            return \"OPYN_GAMMA\";\n        } else if (venueID == uint8(Venues.Charm)) {\n            return \"CHARM\";\n        }\n        return \"\";\n    }\n\n    function getVenueID(string memory venueName) private pure returns (Venues) {\n        if (keccak256(bytes(venueName)) == hegicHash) {\n            return Venues.Hegic;\n        } else if (keccak256(bytes(venueName)) == opynHash) {\n            return Venues.OpynGamma;\n        } else if (keccak256(bytes(venueName)) == charmHash) {\n            return Venues.Charm;\n        }\n        return Venues.Unknown;\n    }\n}\n"
    },
    "contracts/storage/InstrumentStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Initializable} from \"../lib/upgrades/Initializable.sol\";\nimport {IRibbonFactory} from \"../interfaces/IRibbonFactory.sol\";\nimport {ProtocolAdapterTypes} from \"../adapters/IProtocolAdapter.sol\";\nimport {Ownable} from \"../lib/Ownable.sol\";\n\ncontract InstrumentStorageV1 is Initializable, Ownable, ReentrancyGuard {\n    IRibbonFactory public factory;\n    address public underlying;\n    address public strikeAsset;\n    address public collateralAsset;\n    uint256 public expiry;\n    string public name;\n    string public symbol;\n    mapping(address => OldInstrumentPosition[]) private _instrumentPositions;\n\n    uint256[100] private __instrumentGap;\n\n    struct OldInstrumentPosition {\n        bool exercised;\n        ProtocolAdapterTypes.OptionType[] optionTypes;\n        uint32[] optionIDs;\n        uint256[] amounts;\n        uint256[] strikePrices;\n        string[] venues;\n    }\n}\n\nenum Venues {Unknown, Hegic, OpynGamma, Charm}\n\ncontract InstrumentStorageV2 {\n    struct InstrumentPosition {\n        bool exercised;\n        uint8 callVenue;\n        uint8 putVenue;\n        uint32 callOptionID;\n        uint32 putOptionID;\n        uint256 amount;\n        uint256 callStrikePrice;\n        uint256 putStrikePrice;\n    }\n\n    mapping(address => InstrumentPosition[]) instrumentPositions;\n\n    /**\n     * @notice Returns the symbol of the instrument\n     * @param _account is the address which has opened InstrumentPositions\n     */\n    function numOfPositions(address _account) public view returns (uint256) {\n        return instrumentPositions[_account].length;\n    }\n\n    function getInstrumentPositions(address account)\n        external\n        view\n        returns (InstrumentPosition[] memory positions)\n    {\n        return instrumentPositions[account];\n    }\n\n    function instrumentPosition(address account, uint256 positionID)\n        external\n        view\n        returns (InstrumentPosition memory position)\n    {\n        return instrumentPositions[account][positionID];\n    }\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address newOwner) internal {\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), newOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/upgrades/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.2;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/RibbonFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport \"./lib/upgrades/Initializable.sol\";\nimport \"./lib/upgrades/AdminUpgradeabilityProxy.sol\";\nimport {IInstrumentStorage} from \"./interfaces/InstrumentInterface.sol\";\nimport {IChiToken} from \"./interfaces/IChiToken.sol\";\nimport {Ownable} from \"./lib/Ownable.sol\";\n\ncontract RibbonFactoryStorageV1 is Ownable {\n    /**\n     * @notice Address of the admin of all instruments\n     */\n    address public instrumentAdmin;\n\n    /**\n     * @notice Mapping of created instruments\n     */\n    mapping(string => address) public instruments;\n\n    /**\n     * @notice Boolean check for if an address is an instrument\n     */\n    mapping(address => bool) public isInstrument;\n\n    mapping(string => address) public getAdapter;\n\n    address[] public adapters;\n}\n\ncontract RibbonFactory is Initializable, RibbonFactoryStorageV1 {\n    address constant CHI_GAS_TOKEN = 0x0000000000004946c0e9F43F4Dee607b0eF1fA1c;\n    uint256 constant GAS_TOKEN_SUBSIDY = 30;\n\n    /**\n     * @notice Emitted when a new instrument is created\n     */\n    event InstrumentCreated(string symbol, address indexed instrumentAddress);\n\n    /**\n     * @notice Emitted when a new instrument is created\n     */\n    event ProxyCreated(\n        address indexed logic,\n        address indexed proxyAddress,\n        bytes initData\n    );\n\n    event AdapterSet(\n        string indexed protocolName,\n        address indexed adapterAddress\n    );\n\n    /**\n     * @notice Constructor takes a DataProvider contract address\n     */\n    function initialize(address _owner, address _instrumentAdmin)\n        public\n        initializer\n    {\n        Ownable.initialize(_owner);\n        instrumentAdmin = _instrumentAdmin;\n    }\n\n    /**\n     * @notice Getter for getting contract address by instrument name\n     */\n    function getInstrument(string memory _name)\n        public\n        view\n        returns (address instrumentAddress)\n    {\n        instrumentAddress = instruments[_name];\n    }\n\n    function newInstrument(address _logic, bytes memory _initData)\n        public\n        onlyOwner\n        returns (address instrumentAddress)\n    {\n        instrumentAddress = createProxy(_logic, _initData);\n        IInstrumentStorage instrument = IInstrumentStorage(instrumentAddress);\n        string memory symbol = instrument.symbol();\n        require(instruments[symbol] == address(0), \"Instrument already exists\");\n\n        instruments[symbol] = instrumentAddress;\n        isInstrument[instrumentAddress] = true;\n        emit InstrumentCreated(symbol, instrumentAddress);\n    }\n\n    function createProxy(address _logic, bytes memory _initData)\n        private\n        returns (address)\n    {\n        AdminUpgradeabilityProxy proxy =\n            new AdminUpgradeabilityProxy(_logic, instrumentAdmin, _initData);\n        emit ProxyCreated(_logic, address(proxy), _initData);\n        return address(proxy);\n    }\n\n    function burnGasTokens() public {\n        require(isInstrument[msg.sender], \"Caller is not instrument\");\n        IChiToken chiToken = IChiToken(CHI_GAS_TOKEN);\n        chiToken.freeUpTo(GAS_TOKEN_SUBSIDY);\n    }\n\n    function setAdapter(string memory protocolName, address adapter)\n        public\n        onlyOwner\n    {\n        getAdapter[protocolName] = adapter;\n        adapters.push(adapter);\n        emit AdapterSet(protocolName, adapter);\n    }\n\n    function getAdapters() external view returns (address[] memory _adapters) {\n        return adapters;\n    }\n}\n"
    },
    "contracts/lib/upgrades/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.8;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override virtual {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n"
    },
    "contracts/interfaces/InstrumentInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {ProtocolAdapterTypes} from \"../adapters/IProtocolAdapter.sol\";\n\nstruct InstrumentPosition {\n    bool exercised;\n    uint8 callVenue;\n    uint8 putVenue;\n    uint32 callOptionID;\n    uint32 putOptionID;\n    uint256 amount;\n    uint256 callStrikePrice;\n    uint256 putStrikePrice;\n}\n\ninterface IAggregatedOptionsInstrument {\n    function exerciseProfit(address account, uint256 positionID)\n        external\n        view\n        returns (uint256);\n\n    function canExercise(address account, uint256 positionID)\n        external\n        view\n        returns (bool);\n\n    struct BuyInstrumentParams {\n        uint8 callVenue;\n        uint8 putVenue;\n        address paymentToken;\n        uint256 callStrikePrice;\n        uint256 putStrikePrice;\n        uint256 amount;\n        uint256 callMaxCost;\n        uint256 putMaxCost;\n        bytes callBuyData;\n        bytes putBuyData;\n    }\n\n    function buyInstrument(BuyInstrumentParams calldata params)\n        external\n        payable\n        returns (uint256 positionID);\n\n    function exercisePosition(uint256 positionID)\n        external\n        returns (uint256 profit);\n\n    function underlying() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function getInstrumentPositions(address account)\n        external\n        view\n        returns (InstrumentPosition[] memory positions);\n}\n\ninterface IVaultedInstrument {\n    // Deposit and minting processes\n    function deposit(uint256 collateralAmount) external payable;\n\n    function mint(uint256 tokenAmount) external;\n\n    function depositAndMint(uint256 collateralAmount, uint256 tokenAmount)\n        external\n        payable;\n\n    function depositMintAndSell(\n        uint256 collateral,\n        uint256 dToken,\n        uint256 maxSlippage\n    ) external payable;\n\n    // Withdrawals\n    function withdrawAfterExpiry() external;\n\n    // Debt repayment\n    function repayDebt(address vault, uint256 debtAmount) external;\n\n    // Redemption and settlement\n    function settle() external;\n\n    function redeem(uint256 tokenAmount) external;\n}\n\ninterface IInstrumentStorage {\n    function name() external view returns (string memory);\n\n    function dToken() external view returns (address);\n\n    function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IChiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\ninterface IChiToken {\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function mint(uint256 value) external;\n\n    function free(uint256 value) external returns (uint256);\n\n    function freeUpTo(uint256 value) external returns (uint256);\n\n    function freeFrom(address from, uint256 value) external returns (uint256);\n\n    function freeFromUpTo(address from, uint256 value)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/lib/upgrades/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport './Proxy.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "contracts/lib/upgrades/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback () payable external {\n    _fallback();\n  }\n\n  /**\n   * @dev Receive function.\n   * Implemented entirely in `_fallback`.\n   */\n  receive () payable external {\n    // _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal virtual view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "contracts/adapters/HegicAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {\n    AggregatorV3Interface\n} from \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {ProtocolAdapterTypes, IProtocolAdapter} from \"./IProtocolAdapter.sol\";\nimport {\n    State,\n    IHegicOptions,\n    HegicOptionType,\n    IHegicETHOptions,\n    IHegicBTCOptions,\n    IHegicRewards\n} from \"../interfaces/HegicInterface.sol\";\n\nimport {ISwapPair} from \"../interfaces/ISwapPair.sol\";\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\ncontract HegicAdapter is IProtocolAdapter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string private constant _name = \"HEGIC\";\n    bool private constant _nonFungible = true;\n    address public immutable ethAddress;\n    address public constant wethAddress =\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public immutable wbtcAddress;\n    IHegicETHOptions public immutable ethOptions;\n    IHegicBTCOptions public immutable wbtcOptions;\n    ISwapPair public immutable ethWbtcPair;\n\n    /**\n     * @notice constructor for the HegicAdapter\n     * @param _ethOptions is the contract address for the mainnet HegicETHOptions\n     * @param _wbtcOptions is the contract address for the mainnet HegicWBTCOptions\n     * @param _ethAddress is the contract address for Ethereum, defaults to zero address\n     * @param _wbtcOptions is the contract address for mainnet WBTC\n     */\n    constructor(\n        address _ethOptions,\n        address _wbtcOptions,\n        address _ethAddress,\n        address _wbtcAddress,\n        address _ethWbtcPair\n    ) {\n        ethOptions = IHegicETHOptions(_ethOptions);\n        wbtcOptions = IHegicBTCOptions(_wbtcOptions);\n        ethAddress = _ethAddress;\n        wbtcAddress = _wbtcAddress;\n        // add check of correct Pair OR use token addresses to calc the pair address\n        ethWbtcPair = ISwapPair(_ethWbtcPair);\n    }\n\n    receive() external payable {}\n\n    function protocolName() public pure override returns (string memory) {\n        return _name;\n    }\n\n    function nonFungible() external pure override returns (bool) {\n        return _nonFungible;\n    }\n\n    function purchaseMethod()\n        external\n        pure\n        override\n        returns (ProtocolAdapterTypes.PurchaseMethod)\n    {\n        return ProtocolAdapterTypes.PurchaseMethod.Contract;\n    }\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(ProtocolAdapterTypes.OptionTerms calldata optionTerms)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return\n            optionTerms.underlying == ethAddress ||\n            optionTerms.underlying == wbtcAddress;\n    }\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view override returns (address) {\n        if (optionTerms.underlying == ethAddress) {\n            return address(ethOptions);\n        } else if (optionTerms.underlying == wbtcAddress) {\n            return address(wbtcOptions);\n        }\n        require(false, \"No options found\");\n    }\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the purchase amount in Wad units (10**18)\n     */\n    function premium(\n        ProtocolAdapterTypes.OptionTerms memory optionTerms,\n        uint256 purchaseAmount\n    ) public view override returns (uint256 cost) {\n        require(\n            block.timestamp < optionTerms.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        uint256 period = optionTerms.expiry.sub(block.timestamp);\n        uint256 scaledStrikePrice =\n            scaleDownStrikePrice(optionTerms.strikePrice);\n\n        if (optionTerms.underlying == ethAddress) {\n            require(\n                optionTerms.underlying == optionTerms.paymentToken,\n                \"!invalid paymentToken\"\n            );\n            (cost, , , ) = ethOptions.fees(\n                period,\n                purchaseAmount,\n                scaledStrikePrice,\n                HegicOptionType(uint8(optionTerms.optionType))\n            );\n        } else if (optionTerms.underlying == wbtcAddress) {\n            uint256 costWBTC;\n            (costWBTC, cost, , , ) = wbtcOptions.fees(\n                period,\n                purchaseAmount,\n                scaledStrikePrice,\n                HegicOptionType(uint8(optionTerms.optionType))\n            );\n            if (optionTerms.paymentToken == wbtcAddress) {\n                cost = costWBTC;\n            }\n        } else {\n            revert(\"No matching underlying\");\n        }\n    }\n\n    /**\n     * @notice Amount of profit made from exercising an option contract\n     * (current price - strike price). 0 if exercising out-the-money.\n     * @param optionsAddress is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     */\n    function exerciseProfit(\n        address optionsAddress,\n        uint256 optionID,\n        uint256\n    ) public view override returns (uint256 profit) {\n        require(\n            optionsAddress == address(ethOptions) ||\n                optionsAddress == address(wbtcOptions),\n            \"optionsAddress must match either ETH or WBTC options\"\n        );\n        IHegicOptions options = IHegicOptions(optionsAddress);\n\n        AggregatorV3Interface priceProvider =\n            AggregatorV3Interface(options.priceProvider());\n        (, int256 latestPrice, , , ) = priceProvider.latestRoundData();\n        uint256 currentPrice = uint256(latestPrice);\n\n        (\n            ,\n            ,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            ,\n            ,\n            HegicOptionType optionType\n        ) = options.options(optionID);\n\n        if (optionType == HegicOptionType.Call) {\n            if (currentPrice >= strike) {\n                profit = currentPrice.sub(strike).mul(amount).div(currentPrice);\n            } else {\n                profit = 0;\n            }\n        } else {\n            if (currentPrice <= strike) {\n                profit = strike.sub(currentPrice).mul(amount).div(currentPrice);\n            } else {\n                profit = 0;\n            }\n        }\n        if (profit > lockedAmount) profit = lockedAmount;\n    }\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) public view override returns (bool) {\n        bool matchOptionsAddress =\n            options == address(ethOptions) || options == address(wbtcOptions);\n\n        (State state, , , , , , uint256 expiration, ) =\n            IHegicOptions(options).options(optionID);\n        amount = 0;\n\n        uint256 profit = exerciseProfit(options, optionID, amount);\n\n        return\n            matchOptionsAddress &&\n            expiration >= block.timestamp &&\n            state == State.Active &&\n            profit > 0;\n    }\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     * @param maxCost is the max amount of paymentToken to be paid for the option (to avoid sandwich attacks, ...)\n     */\n    function purchase(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable override returns (uint256 optionID) {\n        require(\n            block.timestamp < optionTerms.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        uint256 scaledStrikePrice =\n            scaleDownStrikePrice(optionTerms.strikePrice);\n        uint256 period = optionTerms.expiry.sub(block.timestamp);\n        IHegicOptions options = getHegicOptions(optionTerms.underlying);\n\n        // swap for ETH if ETH has not been provided as paymentToken\n        if (msg.value == 0) {\n            ProtocolAdapterTypes.OptionTerms memory optionTermsWithETH =\n                optionTerms;\n            optionTermsWithETH.paymentToken = ethAddress;\n            uint256 cost = premium(optionTermsWithETH, amount);\n\n            require(\n                optionTerms.paymentToken == wbtcAddress,\n                \"Invalid paymentToken or msg.value\"\n            );\n            uint256 costWBTC = _getAmountsIn(cost);\n            require(maxCost >= costWBTC, \"MaxCost is too low\");\n            _swapWBTCToETH(costWBTC, cost);\n        }\n\n        // Gas optimization to avoid double counting premium()\n        // This will revert if the address(this).balance is not sufficient\n        // Any extras will be refunded to the address(this)\n        // This could potentially be a large security vuln. if the Options contract\n        // does not refund the change\n        optionID = options.create{value: address(this).balance}(\n            period,\n            amount,\n            scaledStrikePrice,\n            HegicOptionType(uint8(optionTerms.optionType))\n        );\n\n        emit Purchased(\n            msg.sender,\n            _name,\n            optionTerms.underlying,\n            msg.value,\n            optionID\n        );\n    }\n\n    /**\n     * @notice Exercises the options contract.\n     * @param optionsAddress is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise.\n     *        Only relevant for fungle protocols like Opyn\n     * @param account is the account that receives the exercised profits.\n     *        This is needed since the adapter holds all the positions and\n     *        the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address optionsAddress,\n        uint256 optionID,\n        uint256 amount,\n        address account\n    ) external payable override {\n        require(\n            optionsAddress == address(ethOptions) ||\n                optionsAddress == address(wbtcOptions),\n            \"optionsAddress must match either ETH or WBTC options\"\n        );\n\n        IHegicOptions options = IHegicOptions(optionsAddress);\n\n        uint256 profit = exerciseProfit(optionsAddress, optionID, amount);\n\n        options.exercise(optionID);\n\n        if (optionsAddress == address(ethOptions)) {\n            (bool success, ) = account.call{value: profit}(\"\");\n            require(success, \"Failed transfer\");\n        } else {\n            IERC20 wbtc = IERC20(wbtcAddress);\n            wbtc.safeTransfer(account, profit);\n        }\n\n        emit Exercised(account, optionsAddress, optionID, amount, profit);\n    }\n\n    function _swapWBTCToETH(uint256 costWBTC, uint256 costETH) internal {\n        IERC20(wbtcAddress).safeTransferFrom(\n            msg.sender,\n            address(ethWbtcPair),\n            costWBTC\n        ); // send WBTC directly to the Uniswap Pair (requires approval of WBTC)\n        uint256 amount0Out;\n        uint256 amount1Out;\n        // in case we change tokens (currently using WETH<>WBTC pair) this should be reviewed\n        (amount0Out, amount1Out) = (uint256(0), costETH);\n        ethWbtcPair.swap(amount0Out, amount1Out, address(this), \"\");\n        IWETH(wethAddress).withdraw(costETH); // unwrapping ETH. It would not be required if options are paid using WETH\n    }\n\n    // from UniswapV2Library\n    function _getAmountsIn(uint256 amountOut)\n        internal\n        view\n        returns (uint256 amountIn)\n    {\n        uint256 reserveIn;\n        uint256 reserveOut;\n        (uint256 reserve0, uint256 reserve1, ) = ethWbtcPair.getReserves();\n        (reserveIn, reserveOut) = (reserve0, reserve1);\n        // getAmountIn\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    /**\n     * @notice Function to get rHEGIC2 rewards claimable from liquidity utilization\n     * @param rewardsAddress is the address of the rewards contract (either for eth or wbtc)\n     * @param optionIDs is an array of all the option ids we want to claim rewards for\n     */\n    function rewardsClaimable(\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external view returns (uint256 rewardsAmount) {\n        IHegicRewards rewardsContract = IHegicRewards(rewardsAddress);\n        IHegicOptions hegicOptions = rewardsContract.hegicOptions();\n        uint256 rewardsRate = rewardsContract.rewardsRate();\n\n        uint256 i = 0;\n\n        while (i < optionIDs.length && optionIDs[i] > 0) {\n            (, , , uint256 _amount, , uint256 _premium, , ) =\n                hegicOptions.options(optionIDs[i]);\n            if (!rewardsContract.rewardedOptions(optionIDs[i])) {\n                rewardsAmount = rewardsAmount.add(\n                    _amount.div(100).add(_premium).mul(rewardsRate).div(1e8)\n                );\n            }\n            i += 1;\n        }\n    }\n\n    /**\n     * @notice Function to get rHEGIC2 rewards claimable from liquidity utilization\n     * @param rewardsAddress is the address of the rewards contract (either for eth or wbtc)\n     * @param optionIDs is an array of all the option ids we want to claim rewards for\n     */\n    function claimRewards(address rewardsAddress, uint256[] calldata optionIDs)\n        external\n        returns (uint256 rewardsAmount)\n    {\n        IHegicRewards rewardsContract = IHegicRewards(rewardsAddress);\n        IERC20 hegicToken = rewardsContract.hegic();\n\n        uint256 i = 0;\n\n        uint256 balanceBefore = hegicToken.balanceOf(address(this));\n\n        while (i < optionIDs.length && optionIDs[i] > 0) {\n            try rewardsContract.getReward(optionIDs[i]) {} catch {}\n            i += 1;\n        }\n\n        uint256 balanceAfter = hegicToken.balanceOf(address(this));\n\n        rewardsAmount = balanceAfter.sub(balanceBefore);\n        require(rewardsAmount > 0, \"No rewards to claim\");\n        hegicToken.safeTransfer(msg.sender, rewardsAmount);\n    }\n\n    function createShort(ProtocolAdapterTypes.OptionTerms memory, uint256)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function closeShort() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Helper function to get the options address based on the underlying asset\n     * @param underlying is the underlying asset for the options\n     */\n    function getHegicOptions(address underlying)\n        private\n        view\n        returns (IHegicOptions)\n    {\n        if (underlying == ethAddress) {\n            return ethOptions;\n        } else if (underlying == wbtcAddress) {\n            return wbtcOptions;\n        }\n        require(false, \"No matching options contract\");\n    }\n\n    /**\n     * @notice Helper function to scale down strike prices from 10**18 to 10**8\n     * @param strikePrice is the strikePrice in 10**18\n     */\n    function scaleDownStrikePrice(uint256 strikePrice)\n        private\n        pure\n        returns (uint256)\n    {\n        // converts strike price in 10**18 to 10**8\n        return strikePrice.div(10**10);\n    }\n}\n"
    },
    "contracts/interfaces/ISwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\ninterface ISwapPair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/adapters/GammaAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\nimport {\n    AggregatorV3Interface\n} from \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProtocolAdapter, ProtocolAdapterTypes} from \"./IProtocolAdapter.sol\";\nimport {\n    IOtokenFactory,\n    OtokenInterface,\n    IController,\n    OracleInterface,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router.sol\";\nimport {DSMath} from \"../lib/DSMath.sol\";\nimport {SafeERC20} from \"../lib/CustomSafeERC20.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\n\ncontract GammaAdapter is IProtocolAdapter, DSMath {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // gammaController is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable gammaController;\n\n    // oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable oTokenFactory;\n\n    // _swapWindow is the number of seconds in which a Uniswap swap is valid from block.timestamp.\n    uint256 private constant SWAP_WINDOW = 900;\n\n    string private constant _name = \"OPYN_GAMMA\";\n    bool private constant _nonFungible = false;\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    uint256 private constant SLIPPAGE_TOLERANCE = 0.75 ether;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // USDCETHPriceFeed is the USDC/ETH Chainlink price feed used\n    // to perform swaps, as an alternative to getAmountsIn\n    AggregatorV3Interface public immutable USDCETHPriceFeed;\n\n    // UNISWAP_ROUTER is Uniswap's periphery contract for conducting trades.\n    // Using this contract is gas inefficient and should only used for convenience i.e. admin functions\n    address public immutable UNISWAP_ROUTER;\n\n    // WETH9 contract\n    address public immutable WETH;\n\n    // USDC is the strike asset in Gamma Protocol\n    address public immutable USDC;\n\n    // 0x proxy for performing buys\n    address public immutable ZERO_EX_EXCHANGE_V3;\n\n    /**\n     * @notice Constructor for the GammaAdapter which initializes a variables\n     * @param _oTokenFactory is the Gamma protocol factory contract which spawns otokens\n     * https://github.com/opynfinance/GammaProtocol/blob/master/contracts/OtokenFactory.sol\n     * @param _gammaController is a top-level contract which allows users to\n     * perform multiple actions in the Gamma protocol\n     * https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n     */\n    constructor(\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _usdcEthPriceFeed,\n        address _uniswapRouter,\n        address _weth,\n        address _usdc,\n        address _zeroExExchange\n    ) {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n        require(_usdcEthPriceFeed != address(0), \"!_usdcEthPriceFeed\");\n        require(_uniswapRouter != address(0), \"!_uniswapRouter\");\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_zeroExExchange != address(0), \"!_zeroExExchange\");\n\n        oTokenFactory = _oTokenFactory;\n        gammaController = _gammaController;\n        MARGIN_POOL = _marginPool;\n        USDCETHPriceFeed = AggregatorV3Interface(_usdcEthPriceFeed);\n        UNISWAP_ROUTER = _uniswapRouter;\n        WETH = _weth;\n        USDC = _usdc;\n        ZERO_EX_EXCHANGE_V3 = _zeroExExchange;\n    }\n\n    receive() external payable {}\n\n    function protocolName() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function nonFungible() external pure override returns (bool) {\n        return _nonFungible;\n    }\n\n    function purchaseMethod()\n        external\n        pure\n        override\n        returns (ProtocolAdapterTypes.PurchaseMethod)\n    {\n        return ProtocolAdapterTypes.PurchaseMethod.ZeroEx;\n    }\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(ProtocolAdapterTypes.OptionTerms calldata optionTerms)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return lookupOToken(optionTerms) != address(0);\n    }\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view override returns (address) {\n        return lookupOToken(optionTerms);\n    }\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     */\n    function premium(ProtocolAdapterTypes.OptionTerms calldata, uint256)\n        external\n        pure\n        override\n        returns (uint256 cost)\n    {\n        return 0;\n    }\n\n    /**\n     * @notice Amount of profit made from exercising an option contract abs(current price - strike price)\n     *         0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param amount is the amount of tokens or options contract to exercise\n     *        Only relevant for fungle protocols like Opyn\n     */\n    function exerciseProfit(\n        address options,\n        uint256,\n        uint256 amount\n    ) public view override returns (uint256 profit) {\n        IController controller = IController(gammaController);\n        OracleInterface oracle = OracleInterface(controller.oracle());\n        OtokenInterface otoken = OtokenInterface(options);\n\n        uint256 spotPrice = oracle.getPrice(otoken.underlyingAsset());\n        uint256 strikePrice = otoken.strikePrice();\n        bool isPut = otoken.isPut();\n\n        if (!isPut && spotPrice <= strikePrice) {\n            return 0;\n        } else if (isPut && spotPrice >= strikePrice) {\n            return 0;\n        }\n\n        return controller.getPayout(options, amount.div(10**10));\n    }\n\n    /**\n     * @notice Helper function that returns true if the option can be exercised now.\n     * @param options is the address of the otoken\n     * @param amount is amount of otokens to exercise\n     */\n    function canExercise(\n        address options,\n        uint256,\n        uint256 amount\n    ) public view override returns (bool) {\n        OtokenInterface otoken = OtokenInterface(options);\n\n        bool settlementAllowed =\n            isSettlementAllowed(\n                otoken.underlyingAsset(),\n                otoken.collateralAsset(),\n                otoken.expiryTimestamp()\n            );\n\n        if (!settlementAllowed) {\n            return false;\n        }\n        // use `0` as the optionID because it doesn't do anything for exerciseProfit\n        if (exerciseProfit(options, 0, amount) > 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Stubbed out for conforming to the IProtocolAdapter interface.\n     */\n    function purchase(\n        ProtocolAdapterTypes.OptionTerms calldata,\n        uint256,\n        uint256\n    ) external payable override returns (uint256) {}\n\n    /**\n     * @notice Purchases otokens using a 0x order struct\n     * It is the obligation of the delegate-calling contract to return the remaining\n     * msg.value back to the user.\n     * @param optionTerms is the terms of the option contract\n     * @param zeroExOrder is the 0x order struct constructed using the 0x API response passed by the frontend.\n     */\n    function purchaseWithZeroEx(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        ProtocolAdapterTypes.ZeroExOrder calldata zeroExOrder\n    ) external payable {\n        require(\n            msg.value >= zeroExOrder.protocolFee,\n            \"Value cannot cover protocolFee\"\n        );\n        require(\n            zeroExOrder.sellTokenAddress == USDC,\n            \"Sell token has to be USDC\"\n        );\n\n        IUniswapV2Router02 router = IUniswapV2Router02(UNISWAP_ROUTER);\n\n        address[] memory path = new address[](2);\n        path[0] = WETH;\n        path[1] = zeroExOrder.sellTokenAddress;\n\n        (, int256 latestPrice, , , ) = USDCETHPriceFeed.latestRoundData();\n\n        // Because we guard that zeroExOrder.sellTokenAddress == USDC\n        // We can assume that the decimals == 6\n        uint256 soldETH =\n            zeroExOrder.takerAssetAmount.mul(uint256(latestPrice)).div(\n                10**assetDecimals(zeroExOrder.sellTokenAddress)\n            );\n\n        router.swapETHForExactTokens{value: soldETH}(\n            zeroExOrder.takerAssetAmount,\n            path,\n            address(this),\n            block.timestamp + SWAP_WINDOW\n        );\n\n        require(\n            IERC20(zeroExOrder.sellTokenAddress).balanceOf(address(this)) >=\n                zeroExOrder.takerAssetAmount,\n            \"Not enough takerAsset balance\"\n        );\n\n        // double approve to fix non-compliant ERC20s\n        IERC20(zeroExOrder.sellTokenAddress).safeApprove(\n            zeroExOrder.allowanceTarget,\n            0\n        );\n        IERC20(zeroExOrder.sellTokenAddress).safeApprove(\n            zeroExOrder.allowanceTarget,\n            zeroExOrder.takerAssetAmount\n        );\n\n        require(\n            address(this).balance >= zeroExOrder.protocolFee,\n            \"Not enough balance for protocol fee\"\n        );\n\n        (bool success, ) =\n            ZERO_EX_EXCHANGE_V3.call{value: zeroExOrder.protocolFee}(\n                zeroExOrder.swapData\n            );\n\n        require(success, \"0x swap failed\");\n\n        require(\n            IERC20(zeroExOrder.buyTokenAddress).balanceOf(address(this)) >=\n                zeroExOrder.makerAssetAmount,\n            \"Not enough buyToken balance\"\n        );\n\n        emit Purchased(\n            msg.sender,\n            _name,\n            optionTerms.underlying,\n            soldETH.add(zeroExOrder.protocolFee),\n            0\n        );\n    }\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param amount is the amount of tokens or options contract to exercise.\n     *        Only relevant for fungle protocols like Opyn\n     * @param recipient is the account that receives the exercised profits.\n     *        This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address options,\n        uint256,\n        uint256 amount,\n        address recipient\n    ) public payable override {\n        OtokenInterface otoken = OtokenInterface(options);\n\n        require(\n            block.timestamp >= otoken.expiryTimestamp(),\n            \"oToken not expired yet\"\n        );\n\n        // Since we accept all amounts in 10**18, we need to normalize it down to the decimals otokens use (10**8)\n        uint256 scaledAmount = amount.div(10**10);\n\n        // use `0` as the optionID because it doesn't do anything for exerciseProfit\n        uint256 profit = exerciseProfit(options, 0, amount);\n\n        require(profit > 0, \"Not profitable to exercise\");\n\n        IController.ActionArgs memory action =\n            IController.ActionArgs(\n                IController.ActionType.Redeem,\n                address(this), // owner\n                address(this), // receiver -  we need this contract to receive so we can swap at the end\n                options, // asset, otoken\n                0, // vaultId\n                scaledAmount,\n                0, //index\n                \"\" //data\n            );\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n        actions[0] = action;\n\n        IController(gammaController).operate(actions);\n\n        uint256 profitInUnderlying =\n            swapExercisedProfitsToUnderlying(options, profit, recipient);\n\n        emit Exercised(msg.sender, options, 0, amount, profitInUnderlying);\n    }\n\n    /**\n     * @notice Swaps the exercised profit (originally in the collateral token) into the `underlying` token.\n     *         This simplifies the payout of an option. Put options pay out in USDC, so we swap USDC back\n     *         into WETH and transfer it to the recipient.\n     * @param otokenAddress is the otoken's address\n     * @param profitInCollateral is the profit after exercising\n     *        denominated in the collateral - this could be a token with different decimals\n     * @param recipient is the recipient of the underlying tokens after the swap\n     */\n    function swapExercisedProfitsToUnderlying(\n        address otokenAddress,\n        uint256 profitInCollateral,\n        address recipient\n    ) internal returns (uint256 profitInUnderlying) {\n        OtokenInterface otoken = OtokenInterface(otokenAddress);\n        address collateral = otoken.collateralAsset();\n        IERC20 collateralToken = IERC20(collateral);\n\n        require(\n            collateralToken.balanceOf(address(this)) >= profitInCollateral,\n            \"Not enough collateral from exercising\"\n        );\n\n        IUniswapV2Router02 router = IUniswapV2Router02(UNISWAP_ROUTER);\n\n        IWETH weth = IWETH(WETH);\n\n        if (collateral == address(weth)) {\n            profitInUnderlying = profitInCollateral;\n            weth.withdraw(profitInCollateral);\n            (bool success, ) = recipient.call{value: profitInCollateral}(\"\");\n            require(success, \"Failed to transfer exercise profit\");\n        } else {\n            // just guard against anything that's not USDC\n            // we will revisit opening up other collateral types for puts\n            // when they get added\n            require(collateral == USDC, \"!USDC\");\n\n            address[] memory path = new address[](2);\n            path[0] = collateral;\n            path[1] = address(weth);\n\n            (, int256 latestPrice, , , ) = USDCETHPriceFeed.latestRoundData();\n\n            profitInUnderlying = wdiv(profitInCollateral, uint256(latestPrice))\n                .mul(10**assetDecimals(collateral));\n\n            require(profitInUnderlying > 0, \"Swap is unprofitable\");\n\n            IERC20(collateral).safeApprove(UNISWAP_ROUTER, profitInCollateral);\n\n            uint256[] memory amountsOut =\n                router.swapExactTokensForETH(\n                    profitInCollateral,\n                    wmul(profitInUnderlying, SLIPPAGE_TOLERANCE),\n                    path,\n                    recipient,\n                    block.timestamp + SWAP_WINDOW\n                );\n\n            profitInUnderlying = amountsOut[1];\n        }\n    }\n\n    /**\n     * @notice Creates a short otoken position by opening a vault, depositing collateral and minting otokens.\n     * The sale of otokens is left to the caller contract to perform.\n     * @param optionTerms is the terms of the option contract\n     * @param depositAmount is the amount deposited to open the vault.\n     *        This amount will determine how much otokens to mint.\n     */\n    function createShort(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 depositAmount\n    ) external override returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        address oToken = lookupOToken(optionTerms);\n        require(oToken != address(0), \"Invalid oToken\");\n\n        address collateralAsset = optionTerms.collateralAsset;\n        if (collateralAsset == address(0)) {\n            collateralAsset = WETH;\n        }\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (optionTerms.optionType == ProtocolAdapterTypes.OptionType.Call) {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n                require(\n                    mintAmount > 0,\n                    \"Must deposit more than 10**8 collateral\"\n                );\n            }\n        } else {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = wdiv(\n                depositAmount.mul(OTOKEN_DECIMALS),\n                optionTerms\n                    .strikePrice\n            )\n                .div(10**collateralDecimals);\n        }\n\n        // double approve to fix non-compliant ERC20s\n        collateralToken.safeApprove(MARGIN_POOL, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oToken, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function closeShort() external override returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No active short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n        OtokenInterface otoken = OtokenInterface(vault.shortOtokens[0]);\n\n        bool settlementAllowed =\n            isSettlementAllowed(\n                otoken.underlyingAsset(),\n                otoken.collateralAsset(),\n                otoken.expiryTimestamp()\n            );\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        IController.ActionArgs[] memory actions;\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        //\n        // If it is before expiry, we need to burn otokens in order to withdraw collateral from the vault\n        if (settlementAllowed) {\n            actions = new IController.ActionArgs[](1);\n\n            actions[0] = IController.ActionArgs(\n                IController.ActionType.SettleVault,\n                address(this), // owner\n                address(this), // address to transfer to\n                address(0), // not used\n                vaultID, // vaultId\n                0, // not used\n                0, // not used\n                \"\" // not used\n            );\n\n            controller.operate(actions);\n        } else {\n            // Burning otokens given by vault.shortAmounts[0] (closing the entire short position),\n            // then withdrawing all the collateral from the vault\n            actions = new IController.ActionArgs[](2);\n\n            actions[0] = IController.ActionArgs(\n                IController.ActionType.BurnShortOption,\n                address(this), // owner\n                address(this), // address to transfer to\n                address(otoken), // otoken address\n                vaultID, // vaultId\n                vault.shortAmounts[0], // amount\n                0, //index\n                \"\" //data\n            );\n\n            actions[1] = IController.ActionArgs(\n                IController.ActionType.WithdrawCollateral,\n                address(this), // owner\n                address(this), // address to transfer to\n                address(collateralToken), // withdrawn asset\n                vaultID, // vaultId\n                vault.collateralAmounts[0], // amount\n                0, //index\n                \"\" //data\n            );\n\n            controller.operate(actions);\n        }\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Gas-optimized getter for checking if settlement is allowed.\n     * Looks up from the oracles with asset address and expiry\n     * @param underlying is the address of the underlying for an otoken\n     * @param collateral is the address of the collateral for an otoken\n     * @param expiry is the timestamp of the otoken's expiry\n     */\n    function isSettlementAllowed(\n        address underlying,\n        address collateral,\n        uint256 expiry\n    ) private view returns (bool) {\n        IController controller = IController(gammaController);\n        OracleInterface oracle = OracleInterface(controller.oracle());\n\n        bool underlyingFinalized =\n            oracle.isDisputePeriodOver(underlying, expiry);\n\n        bool collateralFinalized =\n            (underlying != collateral && collateral != USDC)\n                ? oracle.isDisputePeriodOver(collateral, expiry)\n                : true;\n\n        bool strikeFinalized = oracle.isDisputePeriodOver(USDC, expiry);\n\n        // We can avoid checking the dispute period for the collateral for now\n        // Because the collateral is either the underlying or USDC at this point\n        // We do not have, for example, ETH-collateralized UNI otoken vaults\n        // bool collateralFinalized = oracle.isDisputePeriodOver(isPut ? USDC : underlying, expiry);\n\n        return underlyingFinalized && strikeFinalized && collateralFinalized;\n    }\n\n    /**\n     * @notice Helper function to get the decimals of an asset. Will just hardcode for the time being.\n     * @param asset is the token which we want to know the decimals\n     */\n    function assetDecimals(address asset) private view returns (uint256) {\n        // USDC\n        if (asset == USDC) {\n            return 6;\n        }\n        return 18;\n    }\n\n    /**\n     * @notice Function to lookup oToken addresses. oToken addresses are keyed by an ABI-encoded byte string\n     * @param optionTerms is the terms of the option contract\n     */\n    function lookupOToken(ProtocolAdapterTypes.OptionTerms memory optionTerms)\n        public\n        view\n        returns (address oToken)\n    {\n        IOtokenFactory factory = IOtokenFactory(oTokenFactory);\n\n        bool isPut =\n            optionTerms.optionType == ProtocolAdapterTypes.OptionType.Put;\n        address underlying = optionTerms.underlying;\n\n        /**\n         * In many instances, we just use 0x0 to indicate ETH as the underlying asset.\n         * We need to unify usage of 0x0 as WETH instead.\n         */\n        if (optionTerms.underlying == address(0)) {\n            underlying = WETH;\n        }\n\n        oToken = factory.getOtoken(\n            underlying,\n            optionTerms.strikeAsset,\n            optionTerms.collateralAsset,\n            optionTerms.strikePrice.div(10**10),\n            optionTerms.expiry,\n            isPut\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string calldata);\n}\n"
    },
    "contracts/tests/MockGammaAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {GammaAdapter} from \"../adapters/GammaAdapter.sol\";\n\ncontract MockGammaAdapter is GammaAdapter {\n    constructor(\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _usdcEthPriceFeed,\n        address _uniswapRouter,\n        address _weth,\n        address _usdc,\n        address _zeroExExchange\n    )\n        GammaAdapter(\n            _oTokenFactory,\n            _gammaController,\n            _marginPool,\n            _usdcEthPriceFeed,\n            _uniswapRouter,\n            _weth,\n            _usdc,\n            _zeroExExchange\n        )\n    {}\n\n    function mockedExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external payable {\n        IERC20 otoken = IERC20(options);\n        // simulate burning otokens by transferring it to an unusable address\n        otoken.transfer(\n            0x0000000000000000000000000000000000000069,\n            amount / 10**10\n        );\n\n        exercise(options, optionID, amount, recipient);\n    }\n\n    function swapExercisedProfits(\n        address otokenAddress,\n        uint256 profitInCollateral,\n        address recipient\n    ) external {\n        swapExercisedProfitsToUnderlying(\n            otokenAddress,\n            profitInCollateral,\n            recipient\n        );\n    }\n}\n"
    },
    "contracts/tests/MockRibbonV2Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockRibbonV2Vault {\n    using SafeERC20 for IERC20;\n    address public asset;\n\n    constructor(address token) {\n        asset = token;\n    }\n\n    function depositFor(uint256 amount, address creditor) external {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        // skip actual deposit logic here\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n    }\n}\n"
    },
    "contracts/adapters/CharmAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {\n    AggregatorV3Interface\n} from \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IProtocolAdapter, ProtocolAdapterTypes} from \"./IProtocolAdapter.sol\";\nimport {\n    IOptionMarket,\n    IOptionToken,\n    IOptionViews,\n    IOptionRegistry\n} from \"../interfaces/CharmInterface.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {UniERC20} from \"../lib/UniERC20.sol\";\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router.sol\";\n\ncontract CharmAdapter is IProtocolAdapter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using UniERC20 for IERC20;\n\n    IOptionViews public immutable optionViews;\n    IOptionRegistry public immutable optionRegistry;\n\n    // _swapWindow is the number of seconds in which a Uniswap swap is valid from block.timestamp.\n    uint256 private constant SWAP_WINDOW = 900;\n\n    string private constant _name = \"CHARM\";\n    bool private constant _nonFungible = false;\n\n    // UNISWAP_ROUTER is Uniswap's periphery contract for conducting trades.\n    // Using this contract is gas inefficient and should only used\n    // for convenience i.e. admin functions\n    address private constant UNISWAP_ROUTER =\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    constructor(address _optionViews, address _optionRegistry) {\n        require(_optionViews != address(0), \"!_optionViews\");\n        require(_optionRegistry != address(0), \"!_optionRegistry\");\n        optionViews = IOptionViews(_optionViews);\n        optionRegistry = IOptionRegistry(_optionRegistry);\n    }\n\n    receive() external payable {}\n\n    function protocolName() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function nonFungible() external pure override returns (bool) {\n        return _nonFungible;\n    }\n\n    function purchaseMethod()\n        external\n        pure\n        override\n        returns (ProtocolAdapterTypes.PurchaseMethod)\n    {\n        return ProtocolAdapterTypes.PurchaseMethod.Contract;\n    }\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(ProtocolAdapterTypes.OptionTerms calldata optionTerms)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return address(lookupCToken(optionTerms)) != address(0);\n    }\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view override returns (address) {\n        return address(lookupCToken(optionTerms));\n    }\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     */\n    function premium(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view override returns (uint256 cost) {\n        address tokenAddress = lookupCToken(optionTerms);\n\n        require(tokenAddress != address(0), \"Must be valid option terms!\");\n\n        //get token\n        IOptionToken token = IOptionToken(tokenAddress);\n\n        // Get strike index, whether is long\n        IOptionRegistry.OptionDetails memory optionType =\n            optionRegistry.getOptionDetails(token);\n\n        //get market\n        IOptionMarket market = IOptionMarket(token.market());\n\n        cost = optionViews.getBuyOptionCost(\n            market,\n            optionType.isLongToken,\n            optionType.strikeIndex,\n            purchaseAmount.mul(10**token.decimals()).div(10**18)\n        );\n    }\n\n    /**\n     * @notice Amount of profit made from exercising an option\n     * contract (current price - strike price). 0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param amount is the amount of tokens or options contract to exercise.\n     */\n    function exerciseProfit(\n        address options,\n        uint256,\n        uint256 amount\n    ) public view override returns (uint256) {\n        //get token\n        IOptionToken token = IOptionToken(options);\n        //get market\n        IOptionMarket market = IOptionMarket(token.market());\n\n        // Get strike index, whether is long\n        IOptionRegistry.OptionDetails memory optionType =\n            optionRegistry.getOptionDetails(IOptionToken(options));\n\n        //profit of exercising\n        try\n            optionViews.getSellOptionCost(\n                market,\n                optionType.isLongToken,\n                optionType.strikeIndex,\n                amount.mul(10**token.decimals()).div(10**18)\n            )\n        returns (uint256 v) {\n            return v;\n        } catch {\n            return 0;\n        }\n    }\n\n    function canExercise(\n        address options,\n        uint256,\n        uint256 amount\n    ) public view override returns (bool) {\n        //get token\n        IOptionToken token = IOptionToken(options);\n        //get market\n        IOptionMarket market = IOptionMarket(token.market());\n\n        if (block.timestamp < market.expiryTime()) {\n            return false;\n        }\n        if (exerciseProfit(options, 0, amount) > 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     * @param maxCost is the max amount of paymentToken to be paid for the option (to avoid sandwich attacks, ...)\n     */\n    function purchase(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable override returns (uint256) {\n        require(\n            block.timestamp < optionTerms.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        //get token address\n        address tokenAddress = lookupCToken(optionTerms);\n        if (tokenAddress == address(0)) {\n            try optionRegistry.populateMarkets() {} catch {}\n            tokenAddress = lookupCToken(optionTerms);\n            require(tokenAddress != address(0), \"Market needs to exist!\");\n        }\n\n        //get token\n        IOptionToken token = IOptionToken(tokenAddress);\n\n        // Get strike index, whether is long\n        IOptionRegistry.OptionDetails memory optionType =\n            optionRegistry.getOptionDetails(token);\n\n        //get market\n        IOptionMarket market = IOptionMarket(token.market());\n        IERC20 baseToken =\n            IERC20(\n                optionTerms.optionType == ProtocolAdapterTypes.OptionType.Put\n                    ? optionTerms.strikeAsset\n                    : optionTerms.underlying\n            );\n\n        bool isETH = address(baseToken) == address(0);\n\n        if (!isETH) {\n            _swapETHToBaseToken(baseToken, maxCost, market);\n        }\n\n        uint256 shiftedAmount = amount.mul(10**token.decimals()).div(10**18);\n\n        uint256 amountIn =\n            market.buy{value: isETH ? address(this).balance : 0}(\n                optionType.isLongToken,\n                optionType.strikeIndex,\n                shiftedAmount,\n                maxCost\n            );\n\n        emit Purchased(msg.sender, _name, optionTerms.underlying, amountIn, 0);\n    }\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param amount is the amount of tokens or options contract to exercise.\n     *              Only relevant for fungle protocols like Opyn or Charm\n     * @param recipient is the account that receives the exercised profits.\n     * This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address options,\n        uint256,\n        uint256 amount,\n        address recipient\n    ) public payable override {\n        // Get strike index, whether is long\n        IOptionRegistry.OptionDetails memory optionType =\n            optionRegistry.getOptionDetails(IOptionToken(options));\n\n        //get token\n        IOptionToken token = IOptionToken(options);\n        //get market\n        IOptionMarket market = IOptionMarket(token.market());\n\n        // if we are exercising but market has not settled, do it\n        if (market.isExpired() && !market.isSettled()) {\n            market.settle();\n        }\n\n        uint256 profit = exerciseProfit(options, 0, amount);\n        require(profit > 0, \"Not profitable to exercise\");\n\n        uint256 amountOut =\n            market.sell(\n                optionType.isLongToken,\n                optionType.strikeIndex,\n                amount.mul(10**token.decimals()).div(10**18),\n                profit\n            );\n\n        uint256 profitInUnderlying =\n            _swapExercisedProfitsToUnderlying(\n                market.baseToken(),\n                amountOut,\n                recipient\n            );\n\n        emit Exercised(\n            msg.sender,\n            options,\n            0,\n            amount.mul(10**token.decimals()).div(10**18),\n            profitInUnderlying\n        );\n    }\n\n    function createShort(ProtocolAdapterTypes.OptionTerms memory, uint256)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function closeShort() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Function to lookup cToken addresses.\n     * @param optionTerms is the terms of the option contract\n     */\n    function lookupCToken(ProtocolAdapterTypes.OptionTerms memory optionTerms)\n        public\n        view\n        returns (address token)\n    {\n        bool isPut =\n            optionTerms.optionType == ProtocolAdapterTypes.OptionType.Put;\n\n        //there should only be a collateral asset for charm if we are writing an option\n        bool isLong = optionTerms.collateralAsset == address(1) ? true : false;\n\n        token = address(\n            optionRegistry.getOption(\n                IERC20(optionTerms.underlying),\n                optionTerms.expiry,\n                isPut,\n                optionTerms.strikePrice,\n                isLong\n            )\n        );\n    }\n\n    /**\n     * @notice Swaps the exercised profit (originally in the collateral token) into the `underlying` token.\n     *         This simplifies the payout of an option. Put options pay out in USDC, so we swap USDC back\n     *         into WETH and transfer it to the recipient.\n     * @param baseToken is the base token of the market\n     * @param profitInBaseToken is the profit after exercising denominated in the base token\n     *                          - this could be a token with different decimals\n     * @param recipient is the recipient of the underlying tokens after the swap\n     */\n    function _swapExercisedProfitsToUnderlying(\n        IERC20 baseToken,\n        uint256 profitInBaseToken,\n        address recipient\n    ) private returns (uint256 profitInUnderlying) {\n        require(\n            baseToken.uniBalanceOf(address(this)) >= profitInBaseToken,\n            \"Not enough collateral from exercising\"\n        );\n\n        IUniswapV2Router02 router = IUniswapV2Router02(UNISWAP_ROUTER);\n\n        if (address(baseToken) == address(0)) {\n            (bool success, ) = recipient.call{value: profitInBaseToken}(\"\");\n            require(success, \"Failed to transfer exercise profit\");\n        } else {\n            address[] memory path = new address[](2);\n            path[0] = address(baseToken);\n            path[1] = address(WETH);\n\n            uint256[] memory amountsOut =\n                router.getAmountsOut(profitInBaseToken, path);\n            profitInUnderlying = amountsOut[1];\n\n            require(profitInUnderlying > 0, \"Swap is unprofitable\");\n\n            baseToken.safeApprove(address(router), profitInBaseToken);\n\n            router.swapExactTokensForETH(\n                profitInBaseToken,\n                profitInUnderlying,\n                path,\n                recipient,\n                block.timestamp + SWAP_WINDOW\n            );\n        }\n    }\n\n    /**\n     * @notice Swaps the ETH into the `base` token.\n     *         This simplifies the buying of an option since you only pay in ETH for any option\n     * @param baseToken is the base token of the market\n     * @param _premium premium to buy option\n     * @param market market of token\n     */\n    function _swapETHToBaseToken(\n        IERC20 baseToken,\n        uint256 _premium,\n        IOptionMarket market\n    ) private {\n        IUniswapV2Router02 router = IUniswapV2Router02(UNISWAP_ROUTER);\n\n        address[] memory path = new address[](2);\n        path[0] = WETH;\n        path[1] = address(baseToken);\n\n        router.swapETHForExactTokens{value: address(this).balance}(\n            _premium,\n            path,\n            address(this),\n            block.timestamp + SWAP_WINDOW\n        );\n\n        uint256 balanceOfToken = baseToken.uniBalanceOf(address(this));\n        baseToken.safeApprove(address(market), balanceOfToken);\n    }\n}\n"
    },
    "contracts/interfaces/CharmInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IOptionMarket {\n    function baseToken() external view returns (IERC20);\n\n    function longTokens(uint256 index) external view returns (IOptionToken);\n\n    function shortTokens(uint256 index) external view returns (IOptionToken);\n\n    function strikePrices(uint256 index) external view returns (uint256);\n\n    function expiryTime() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function isSettled() external view returns (bool);\n\n    function buy(\n        bool isLongToken,\n        uint256 strikeIndex,\n        uint256 optionsOut,\n        uint256 maxAmountIn\n    ) external payable returns (uint256);\n\n    function sell(\n        bool isLongToken,\n        uint256 strikeIndex,\n        uint256 optionsIn,\n        uint256 minAmountOut\n    ) external returns (uint256);\n\n    function settle() external;\n\n    function isExpired() external view returns (bool);\n\n    function numStrikes() external view returns (uint256);\n}\n\ninterface IOptionToken {\n    function market() external pure returns (address);\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IOptionViews {\n    function getBuyOptionCost(\n        IOptionMarket market,\n        bool isLongToken,\n        uint256 strikeIndex,\n        uint256 optionsOut\n    ) external view returns (uint256);\n\n    function getSellOptionCost(\n        IOptionMarket market,\n        bool isLongToken,\n        uint256 strikeIndex,\n        uint256 optionsIn\n    ) external view returns (uint256);\n}\n\ninterface IOptionRegistry {\n    struct OptionDetails {\n        bool isLongToken;\n        uint256 strikeIndex;\n        uint256 strikePrice;\n    }\n\n    function getOption(\n        IERC20 underlying,\n        uint256 expiryTime,\n        bool isPut,\n        uint256 strikePrice,\n        bool isLong\n    ) external view returns (IOptionToken);\n\n    function getOptionDetails(IOptionToken optionToken)\n        external\n        view\n        returns (OptionDetails memory);\n\n    function populateMarkets() external;\n}\n"
    },
    "contracts/lib/UniERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Originally: https://github.com/CryptoManiacsZone/mooniswap/blob/master/contracts/libraries/UniERC20.sol\n\n// MIT License\n//\n// Copyright (c) 2020 Mooniswap\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// Changes made from original:\n// - Use call instead of transfer\n\npragma solidity >=0.7.2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nlibrary UniERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (address(token) == address(0));\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"Transfer failed\");\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniTransferFromSenderToThis(IERC20 token, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                require(msg.value >= amount, \"UniERC20: not enough value\");\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    uint256 refundAmount = msg.value.sub(amount);\n                    (bool success, ) = msg.sender.call{value: refundAmount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            } else {\n                token.safeTransferFrom(msg.sender, address(this), amount);\n            }\n        }\n    }\n\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(abi.encodeWithSignature(\"symbol()\"));\n        if (!success) {\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSignature(\"SYMBOL()\"));\n        }\n\n        if (success && data.length >= 96) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            if (offset == 0x20 && len > 0 && len <= 256) {\n                return string(abi.decode(data, (bytes)));\n            }\n        }\n\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                len++;\n            }\n\n            if (len > 0) {\n                bytes memory result = new bytes(len);\n                for (uint256 i = 0; i < len; i++) {\n                    result[i] = data[i];\n                }\n                return string(result);\n            }\n        }\n\n        return _toHex(address(token));\n    }\n\n    function _toHex(address account) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(account));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        uint256 j = 2;\n        for (uint256 i = 0; i < data.length; i++) {\n            uint256 a = uint8(data[i]) >> 4;\n            uint256 b = uint8(data[i]) & 0x0f;\n            str[j++] = bytes1(uint8(a + 48 + (a / 10) * 39));\n            str[j++] = bytes1(uint8(b + 48 + (b / 10) * 39));\n        }\n\n        return string(str);\n    }\n}\n"
    },
    "contracts/tests/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 supply\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, supply);\n    }\n\n    function mintTo(address _account, uint256 _amount) public {\n        _mint(_account, _amount);\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        _setupDecimals(_decimals);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/VaultRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.2;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract VaultRegistry is Ownable {\n    /// @dev Register vaults that can withdraw for free to each other\n    /// mapping(fromVault => mapping(toVault => true/false))\n    mapping(address => mapping(address => bool)) public canWithdrawForFree;\n\n    /// @dev Register vaults that can trade with each other\n    /// mapping(longVault => mapping(shortVault => true/false))\n    mapping(address => mapping(address => bool)) public canCrossTrade;\n\n    event RegisterWithdrawal(address fromVault, address toVault);\n\n    event RevokeWithdrawal(address fromVault, address toVault);\n\n    event RegisterCrossTrade(address longVault, address shortVault);\n\n    event RevokeCrossTrade(address longVault, address shortVault);\n\n    /**\n     * @notice Register vaults that can withdraw to each other for free\n     * @param fromVault is the vault to withdraw from\n     * @param toVault is the vault to withdraw to\n     */\n    function registerFreeWithdrawal(address fromVault, address toVault)\n        external\n        onlyOwner\n    {\n        canWithdrawForFree[fromVault][toVault] = true;\n        emit RegisterWithdrawal(fromVault, toVault);\n    }\n\n    /**\n     * @notice Revoke withdrawal access between vaults\n     * @param fromVault is the vault to withdraw from\n     * @param toVault is the vault to withdraw to\n     */\n    function revokeFreeWithdrawal(address fromVault, address toVault)\n        external\n        onlyOwner\n    {\n        canWithdrawForFree[fromVault][toVault] = false;\n        emit RevokeWithdrawal(fromVault, toVault);\n    }\n\n    /**\n     * @notice Register vaults that can trade options with each other\n     * @param longVault is the vault that is buying options\n     * @param shortVault is the vault that is selling options\n     */\n    function registerCrossTrade(address longVault, address shortVault)\n        external\n        onlyOwner\n    {\n        canCrossTrade[longVault][shortVault] = true;\n        emit RegisterCrossTrade(longVault, shortVault);\n    }\n\n    /**\n     * @notice Revoke trading access between vaults\n     * @param longVault is the vault that is buying options\n     * @param shortVault is the vault that is selling options\n     */\n    function revokeCrossTrade(address longVault, address shortVault)\n        external\n        onlyOwner\n    {\n        canCrossTrade[longVault][shortVault] = false;\n        emit RevokeCrossTrade(longVault, shortVault);\n    }\n}\n"
    },
    "contracts/lib/upgrades/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./AdminUpgradeabilityProxy.sol\";\n\n/**\n * @title ProxyAdmin\n * @dev This contract is the admin of a proxy, and is in charge\n * of upgrading it as well as transferring it to another admin.\n */\ncontract ProxyAdmin is Ownable {\n  \n  /**\n   * @dev Returns the current implementation of a proxy.\n   * This is needed because only the proxy admin can query it.\n   * @return The address of the current implementation of the proxy.\n   */\n  function getProxyImplementation(AdminUpgradeabilityProxy proxy) public view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Returns the admin of a proxy. Only the admin can query it.\n   * @return The address of the current admin of the proxy.\n   */\n  function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of a proxy.\n   * @param proxy Proxy to change admin.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner {\n    proxy.changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrades a proxy to the newest implementation of a contract.\n   * @param proxy Proxy to be upgraded.\n   * @param implementation the address of the Implementation.\n   */\n  function upgrade(AdminUpgradeabilityProxy proxy, address implementation) public onlyOwner {\n    proxy.upgradeTo(implementation);\n  }\n\n  /**\n   * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n   * This is useful to initialize the proxied contract.\n   * @param proxy Proxy to be upgraded.\n   * @param implementation Address of the Implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes memory data) payable public onlyOwner {\n    proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}